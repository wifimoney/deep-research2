{"version":3,"sources":["../src/voice/voice.ts","../src/voice/aisdk/speech.ts","../src/voice/aisdk/transcription.ts","../src/voice/composite-voice.ts","../src/voice/default-voice.ts"],"names":["MastraVoice","__decoratorStart","__decorateElement","__runInitializers","experimental_generateSpeech","stream","PassThrough","experimental_transcribe","MastraError"],"mappings":"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","file":"chunk-3IDFSGG3.cjs","sourcesContent":["import type { ToolsInput } from '../agent';\nimport { MastraBase } from '../base';\nimport { InstrumentClass } from '../telemetry';\n\nexport type VoiceEventType = 'speaking' | 'writing' | 'error' | string;\n\nexport interface VoiceEventMap {\n  speaker: NodeJS.ReadableStream;\n  speaking: { audio?: string };\n  writing: { text: string; role: 'assistant' | 'user' };\n  error: { message: string; code?: string; details?: unknown };\n  [key: string]: unknown;\n}\n\ninterface BuiltInModelConfig {\n  name: string;\n  apiKey?: string;\n}\n\nexport interface VoiceConfig<T = unknown> {\n  listeningModel?: BuiltInModelConfig;\n  speechModel?: BuiltInModelConfig;\n  speaker?: string;\n  name?: string;\n  realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: T;\n  };\n}\n\n@InstrumentClass({\n  prefix: 'voice',\n  excludeMethods: ['__setTools', '__setLogger', '__setTelemetry', '#log'],\n})\nexport abstract class MastraVoice<\n  TOptions = unknown,\n  TSpeakOptions = unknown,\n  TListenOptions = unknown,\n  TTools extends ToolsInput = ToolsInput,\n  TEventArgs extends VoiceEventMap = VoiceEventMap,\n  TSpeakerMetadata = unknown,\n> extends MastraBase {\n  protected listeningModel?: BuiltInModelConfig;\n  protected speechModel?: BuiltInModelConfig;\n  protected speaker?: string;\n  protected realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: TOptions;\n  };\n\n  constructor({ listeningModel, speechModel, speaker, realtimeConfig, name }: VoiceConfig<TOptions> = {}) {\n    super({\n      component: 'VOICE',\n      name,\n    });\n    this.listeningModel = listeningModel;\n    this.speechModel = speechModel;\n    this.speaker = speaker;\n    this.realtimeConfig = realtimeConfig;\n  }\n\n  traced<T extends Function>(method: T, methodName: string): T {\n    return (\n      this.telemetry?.traceMethod(method, {\n        spanName: `voice.${methodName}`,\n        attributes: {\n          'voice.type': this.speechModel?.name || this.listeningModel?.name || 'unknown',\n        },\n      }) ?? method\n    );\n  }\n\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream\n   */\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in chat mode\n   */\n  abstract speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n    } & TSpeakOptions,\n  ): Promise<NodeJS.ReadableStream | void>;\n\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text or text stream\n   */\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text, text stream, or void if in chat mode\n   */\n  abstract listen(\n    audioStream: NodeJS.ReadableStream | unknown, // Allow other audio input types for OpenAI realtime API\n    options?: TListenOptions,\n  ): Promise<string | NodeJS.ReadableStream | void>;\n\n  updateConfig(_options: Record<string, unknown>): void {\n    this.logger.warn('updateConfig not implemented by this voice provider');\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(_options?: Record<string, unknown>): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('connect not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to relay\n   */\n  send(_audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('relay not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(_options?: Record<string, unknown>): Promise<void> {\n    this.logger.warn('answer not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(_instructions?: string): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(_tools: TTools): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('close not implemented by this voice provider');\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('on not implemented by this voice provider');\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('off not implemented by this voice provider');\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getSpeakers(): Promise<\n    Array<\n      {\n        voiceId: string;\n      } & TSpeakerMetadata\n    >\n  > {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getSpeakers not implemented by this voice provider');\n    return Promise.resolve([]);\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getListener(): Promise<{ enabled: boolean }> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getListener not implemented by this voice provider');\n    return Promise.resolve({ enabled: false });\n  }\n}\n","import { PassThrough } from 'stream';\nimport { experimental_generateSpeech } from 'ai-v5';\nimport type { SpeechModel } from 'ai-v5';\nimport { MastraVoice } from '../voice';\n\nexport class AISDKSpeech extends MastraVoice {\n  private model: SpeechModel;\n  private defaultVoice?: string;\n\n  constructor(model: SpeechModel, options?: { voice?: string }) {\n    super({ name: 'ai-sdk-speech' });\n    this.model = model;\n    this.defaultVoice = options?.voice;\n  }\n\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n      language?: string;\n      providerOptions?: Record<string, any>;\n      abortSignal?: AbortSignal;\n      headers?: Record<string, string>;\n    },\n  ): Promise<NodeJS.ReadableStream> {\n    // Convert stream to text if needed\n    const text = typeof input === 'string' ? input : await this.streamToText(input);\n\n    const result = await experimental_generateSpeech({\n      model: this.model,\n      text,\n      voice: options?.speaker || this.defaultVoice, // Map speaker to AI SDK's voice parameter\n      language: options?.language,\n      providerOptions: options?.providerOptions,\n      abortSignal: options?.abortSignal,\n      headers: options?.headers,\n    });\n\n    // Convert Uint8Array to Node stream\n    const stream = new PassThrough();\n    stream.end(Buffer.from(result.audio.uint8Array));\n    return stream;\n  }\n\n  async listen(): Promise<string> {\n    throw new Error('AI SDK speech models do not support transcription. Use AISDKTranscription instead.');\n  }\n\n  async getSpeakers() {\n    // Return empty array - voice must be specified in speak() options\n    return [];\n  }\n\n  async getListener() {\n    return { enabled: false };\n  }\n\n  private async streamToText(stream: NodeJS.ReadableStream): Promise<string> {\n    const chunks: Buffer[] = [];\n    for await (const chunk of stream) {\n      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n    }\n    return Buffer.concat(chunks).toString('utf-8');\n  }\n}\n","import { experimental_transcribe } from 'ai-v5';\nimport type { TranscriptionModel } from 'ai-v5';\nimport { MastraVoice } from '../voice';\n\nexport class AISDKTranscription extends MastraVoice {\n  private model: TranscriptionModel;\n\n  constructor(model: TranscriptionModel) {\n    super({ name: 'ai-sdk-transcription' });\n    this.model = model;\n  }\n\n  async speak(): Promise<NodeJS.ReadableStream> {\n    throw new Error('AI SDK transcription models do not support text-to-speech. Use AISDKSpeech instead.');\n  }\n\n  async getSpeakers() {\n    return [];\n  }\n\n  async getListener() {\n    return { enabled: true };\n  }\n\n  /**\n   * Transcribe audio to text\n   * For enhanced metadata (segments, language, duration), use AI SDK's transcribe() directly\n   */\n  async listen(\n    audioStream: NodeJS.ReadableStream,\n    options?: {\n      providerOptions?: Record<string, any>;\n      abortSignal?: AbortSignal;\n      headers?: Record<string, string>;\n    },\n  ): Promise<string> {\n    const audioBuffer = await this.convertToBuffer(audioStream);\n\n    const result = await experimental_transcribe({\n      model: this.model,\n      audio: audioBuffer,\n      providerOptions: options?.providerOptions,\n      abortSignal: options?.abortSignal,\n      headers: options?.headers,\n    });\n\n    return result.text;\n  }\n\n  private async convertToBuffer(audio: NodeJS.ReadableStream | Buffer | Uint8Array | string): Promise<Buffer> {\n    if (Buffer.isBuffer(audio)) return audio;\n    if (audio instanceof Uint8Array) return Buffer.from(audio);\n    if (typeof audio === 'string') return Buffer.from(audio, 'base64');\n\n    const chunks: Buffer[] = [];\n    for await (const chunk of audio) {\n      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n    }\n    return Buffer.concat(chunks);\n  }\n}\n","import type { TranscriptionModel, SpeechModel } from 'ai-v5';\n\nimport type { ToolsInput } from '../agent';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\n\nimport { AISDKSpeech } from './aisdk/speech';\nimport { AISDKTranscription } from './aisdk/transcription';\nimport { MastraVoice } from './voice';\nimport type { VoiceEventType, VoiceEventMap } from '.';\n\n// Helper to check if something is an AI SDK model\nfunction isTranscriptionModel(obj: any): obj is TranscriptionModel {\n  return obj && typeof obj === 'object' && obj.modelId && obj.specificationVersion === 'v2';\n}\n\nfunction isSpeechModel(obj: any): obj is SpeechModel {\n  return obj && typeof obj === 'object' && obj.modelId && obj.specificationVersion === 'v2';\n}\n\nexport class CompositeVoice extends MastraVoice<unknown, unknown, unknown, ToolsInput, VoiceEventMap> {\n  protected speakProvider?: MastraVoice;\n  protected listenProvider?: MastraVoice;\n  protected realtimeProvider?: MastraVoice;\n\n  constructor({\n    input,\n    output,\n    realtime,\n    speakProvider,\n    listenProvider,\n    realtimeProvider,\n  }: {\n    /** @deprecated use output instead */\n    speakProvider?: MastraVoice;\n    /** @deprecated use input instead */\n    listenProvider?: MastraVoice;\n    /** @deprecated use realtime instead */\n    realtimeProvider?: MastraVoice;\n\n    input?: MastraVoice | TranscriptionModel;\n    output?: MastraVoice | SpeechModel;\n    realtime?: MastraVoice;\n  }) {\n    super();\n\n    // Handle deprecated params for backward compatibility\n    const inputProvider = input || listenProvider;\n    const outputProvider = output || speakProvider;\n\n    // Auto-wrap AI SDK models\n    if (inputProvider) {\n      this.listenProvider = isTranscriptionModel(inputProvider) ? new AISDKTranscription(inputProvider) : inputProvider;\n    }\n\n    if (outputProvider) {\n      this.speakProvider = isSpeechModel(outputProvider) ? new AISDKSpeech(outputProvider) : outputProvider;\n    }\n\n    this.realtimeProvider = realtime || realtimeProvider;\n  }\n\n  /**\n   * Convert text to speech using the configured provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in realtime mode\n   */\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: { speaker?: string } & any,\n  ): Promise<NodeJS.ReadableStream | void> {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.speak(input, options);\n    } else if (this.speakProvider) {\n      return this.speakProvider.speak(input, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAK_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(audioStream: NodeJS.ReadableStream, options?: any) {\n    if (this.realtimeProvider) {\n      return await this.realtimeProvider.listen(audioStream, options);\n    } else if (this.listenProvider) {\n      return await this.listenProvider.listen(audioStream, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTEN_PROVIDER',\n      text: 'No listen provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getSpeakers();\n    } else if (this.speakProvider) {\n      return this.speakProvider.getSpeakers();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAKERS_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getListener();\n    } else if (this.listenProvider) {\n      return this.listenProvider.getListener();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTENER_PROVIDER',\n      text: 'No listener provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  updateConfig(options: Record<string, unknown>): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.updateConfig(options);\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CONNECT',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.connect(options);\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to send\n   */\n  send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_SEND',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.send(audioData);\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ANSWER',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.answer(options);\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(instructions: string): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addInstructions(instructions);\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(tools: ToolsInput): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addTools(tools);\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CLOSE',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.close();\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ON',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.on(event, callback);\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_OFF',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.off(event, callback);\n  }\n}\n","import { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport { MastraVoice } from '.';\n\nexport class DefaultVoice extends MastraVoice {\n  constructor() {\n    super();\n  }\n\n  async speak(_input: string | NodeJS.ReadableStream): Promise<NodeJS.ReadableStream> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAK_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(_input: string | NodeJS.ReadableStream): Promise<string> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTEN_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers(): Promise<{ voiceId: string }[]> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAKERS_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener(): Promise<{ enabled: boolean }> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTENER_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n}\n"]}