{"version":3,"sources":["../src/tools/stream.ts"],"names":["WritableStream"],"mappings":";;;;;AAGO,IAAM,UAAA,GAAN,cAA4BA,kBAAA,CAAkB;AAAA,EACnD,cAAA;AAAA,EACQ,UAAA,GAA4B,QAAQ,OAAA,EAAQ;AAAA,EAEpD,WAAA,CACE;AAAA,IACE,MAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,IACA;AAAA,KAOF,cAAA,EACA;AACA,IAAA,KAAA,CAAM;AAAA,MACJ,MAAM,MAAM,KAAA,EAAY;AACtB,QAAA,MAAM,MAAA,GAAS,gBAAgB,SAAA,EAAU;AAEzC,QAAA,IAAI;AACF,UAAA,MAAM,QAAQ,KAAA,CAAM;AAAA,YAClB,IAAA,EAAM,GAAG,MAAM,CAAA,OAAA,CAAA;AAAA,YACf,KAAA;AAAA,YACA,IAAA,EAAM,MAAA;AAAA,YACN,OAAA,EAAS;AAAA,cACP,MAAA,EAAQ,KAAA;AAAA,cACR,GAAI,WAAW,eAAA,GACX;AAAA,gBACE,KAAA;AAAA,gBACA,QAAA,EAAU;AAAA,eACZ,GACA;AAAA,gBACE,CAAC,CAAA,EAAG,MAAM,CAAA,MAAA,CAAQ,GAAG,MAAA;AAAA,gBACrB,CAAC,CAAA,EAAG,MAAM,CAAA,IAAA,CAAM,GAAG;AAAA;AACrB;AACN,WACD,CAAA;AAAA,QACH,CAAA,SAAE;AACA,UAAA,MAAA,EAAQ,WAAA,EAAY;AAAA,QACtB;AAAA,MACF;AAAA,KACD,CAAA;AACD,IAAA,IAAA,CAAK,cAAA,GAAiB,cAAA;AAAA,EACxB;AAAA,EAEA,MAAM,MAAM,IAAA,EAAW;AACrB,IAAA,MAAM,MAAA,GAAS,KAAK,SAAA,EAAU;AAE9B,IAAA,IAAI;AACF,MAAA,MAAM,MAAA,CAAO,MAAM,IAAI,CAAA;AAAA,IACzB,CAAA,SAAE;AACA,MAAA,MAAA,CAAO,WAAA,EAAY;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAM,OAAmC,IAAA,EAAgE;AAEvG,IAAA,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,YAAY;AACjD,MAAA,IAAI,CAAC,KAAK,cAAA,EAAgB;AACxB,QAAA;AAAA,MACF;AAEA,MAAA,MAAM,MAAA,GAAS,IAAA,CAAK,cAAA,CAAe,SAAA,EAAU;AAC7C,MAAA,IAAI;AACF,QAAA,MAAM,MAAA,CAAO,MAAM,IAAI,CAAA;AAAA,MACzB,CAAA,SAAE;AACA,QAAA,MAAA,CAAO,WAAA,EAAY;AAAA,MACrB;AAAA,IACF,CAAC,CAAA;AAED,IAAA,OAAO,IAAA,CAAK,UAAA;AAAA,EACd;AACF","file":"chunk-X7F4CSGR.cjs","sourcesContent":["import { WritableStream } from 'stream/web';\nimport type { DataChunkType } from '../stream/types';\n\nexport class ToolStream<T> extends WritableStream<T> {\n  originalStream?: WritableStream;\n  private writeQueue: Promise<void> = Promise.resolve();\n\n  constructor(\n    {\n      prefix,\n      callId,\n      name,\n      runId,\n    }: {\n      prefix: string;\n      callId: string;\n      name: string;\n      runId: string;\n    },\n    originalStream?: WritableStream,\n  ) {\n    super({\n      async write(chunk: any) {\n        const writer = originalStream?.getWriter();\n\n        try {\n          await writer?.write({\n            type: `${prefix}-output`,\n            runId,\n            from: 'USER',\n            payload: {\n              output: chunk,\n              ...(prefix === 'workflow-step'\n                ? {\n                    runId,\n                    stepName: name,\n                  }\n                : {\n                    [`${prefix}CallId`]: callId,\n                    [`${prefix}Name`]: name,\n                  }),\n            },\n          });\n        } finally {\n          writer?.releaseLock();\n        }\n      },\n    });\n    this.originalStream = originalStream;\n  }\n\n  async write(data: any) {\n    const writer = this.getWriter();\n\n    try {\n      await writer.write(data);\n    } finally {\n      writer.releaseLock();\n    }\n  }\n\n  async custom<T extends { type: string }>(data: T extends { type: `data-${string}` } ? DataChunkType : T) {\n    // Queue the write operation to prevent concurrent access to the writer\n    this.writeQueue = this.writeQueue.then(async () => {\n      if (!this.originalStream) {\n        return;\n      }\n\n      const writer = this.originalStream.getWriter();\n      try {\n        await writer.write(data);\n      } finally {\n        writer.releaseLock();\n      }\n    });\n\n    return this.writeQueue;\n  }\n}\n"]}