{"version":3,"file":"xstate.umd.min.js","sources":["../src/Mailbox.ts","../src/constants.ts","../src/dev/index.ts","../src/eventUtils.ts","../src/reportUnhandledError.ts","../src/symbolObservable.ts","../src/utils.ts","../src/system.ts","../src/createActor.ts","../src/actions/cancel.ts","../src/actions/spawnChild.ts","../src/actions/stopChild.ts","../src/guards.ts","../src/stateUtils.ts","../src/State.ts","../src/spawn.ts","../src/actions/assign.ts","../src/actions/emit.ts","../src/actions/raise.ts","../src/types.ts","../src/actions/send.ts","../src/actions/enqueueActions.ts","../src/actions/log.ts","../src/actors/transition.ts","../src/actors/callback.ts","../src/actors/observable.ts","../src/actors/promise.ts","../src/actors/index.ts","../src/memo.ts","../src/StateNode.ts","../src/StateMachine.ts","../src/createMachine.ts","../src/getNextSnapshot.ts","../src/waitFor.ts","../src/SimulatedClock.ts","../src/assert.ts","../src/transition.ts","../src/setup.ts","../src/toPromise.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if ((w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY, WILDCARD } from './constants.ts';\nimport type {\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  const result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n\n/**\n * Checks if an event type matches an event descriptor, supporting wildcards.\n * Event descriptors can be:\n *\n * - Exact matches: \"event.type\"\n * - Wildcard: \"*\"\n * - Partial matches: \"event.*\"\n *\n * @param eventType - The actual event type string\n * @param descriptor - The event descriptor to match against\n * @returns True if the event type matches the descriptor\n */\nexport function matchesEventDescriptor(\n  eventType: string,\n  descriptor: string\n): boolean {\n  if (descriptor === eventType) {\n    return true;\n  }\n\n  if (descriptor === WILDCARD) {\n    return true;\n  }\n\n  if (!descriptor.endsWith('.*')) {\n    return false;\n  }\n\n  if (isDevelopment && /.*\\*.+/.test(descriptor)) {\n    console.warn(\n      `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`\n    );\n  }\n\n  const partialEventTokens = descriptor.split('.');\n  const eventTokens = eventType.split('.');\n\n  for (\n    let tokenIndex = 0;\n    tokenIndex < partialEventTokens.length;\n    tokenIndex++\n  ) {\n    const partialEventToken = partialEventTokens[tokenIndex];\n    const eventToken = eventTokens[tokenIndex];\n\n    if (partialEventToken === '*') {\n      const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n      if (isDevelopment && !isLastToken) {\n        console.warn(\n          `Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`\n        );\n      }\n\n      return isLastToken;\n    }\n\n    if (partialEventToken !== eventToken) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  HomomorphicOmit,\n  EventObject,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  getAll: () => Partial<T['actors']>;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach((observer) =>\n      observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any] | undefined;\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries()) as Partial<T['actors']>;\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\n// those are needed to make JSDoc `@link` work properly\nimport type {\n  fromObservable,\n  fromEventObservable\n} from './actors/observable.ts';\nimport type { fromCallback } from './actors/callback.ts';\nimport type { fromPromise } from './actors/promise.ts';\nimport type { fromTransition } from './actors/transition.ts';\nimport type { createMachine } from './createMachine.ts';\n\nexport let executingCustomAction: boolean = false;\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  public systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: (action) => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> &\n        (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n): BuiltinActionResolution {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, { sendId: resolvedSendId }, undefined];\n}\n\nfunction executeCancel(actorScope: AnyActorScope, params: { sendId: string }) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<TContext, TExpressionEvent, TParams, TEvent>\n): CancelAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function cancel(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus, createActor } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  EventObject,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  MachineContext,\n  Mapper,\n  ParameterizedObject,\n  ProvidedActor,\n  RequiredActorOptions,\n  BuiltinActionResolution,\n  UnifiedArg\n} from '../types.ts';\nimport { resolveReferencedActor } from '../utils.ts';\n\ntype ResolvableActorId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TId extends string | undefined\n> = TId | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TId);\n\nfunction resolveSpawn(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  _actionParams: ParameterizedObject['params'] | undefined,\n  {\n    id,\n    systemId,\n    src,\n    input,\n    syncSnapshot\n  }: {\n    id: ResolvableActorId<MachineContext, EventObject, EventObject, string>;\n    systemId: string | undefined;\n    src: AnyActorLogic | string;\n    input?: unknown;\n    syncSnapshot: boolean;\n  }\n): BuiltinActionResolution {\n  const logic =\n    typeof src === 'string'\n      ? resolveReferencedActor(snapshot.machine, src)\n      : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef: AnyActorRef | undefined;\n  let resolvedInput: unknown | undefined = undefined;\n\n  if (logic) {\n    resolvedInput =\n      typeof input === 'function'\n        ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n          })\n        : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n\n  if (isDevelopment && !actorRef) {\n    console.warn(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n      `Actor type '${src}' not found in machine '${actorScope.id}'.`\n    );\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children: {\n        ...snapshot.children,\n        [resolvedId]: actorRef!\n      }\n    }),\n    {\n      id,\n      systemId,\n      actorRef,\n      src,\n      input: resolvedInput\n    },\n    undefined\n  ];\n}\n\nfunction executeSpawn(\n  actorScope: AnyActorScope,\n  { actorRef }: { id: string; actorRef: AnyActorRef }\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\n\nexport interface SpawnAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\ninterface SpawnActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, TActor['id']>;\n  systemId?: string;\n  input?:\n    | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>\n    | InputFrom<TActor['logic']>;\n  syncSnapshot?: boolean;\n}\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  | (TActor extends any\n      ? ConditionalRequired<\n          [\n            src: TActor['src'],\n            options?: SpawnActionOptions<\n              TContext,\n              TExpressionEvent,\n              TEvent,\n              TActor\n            > & {\n              [K in RequiredActorOptions<TActor>]: unknown;\n            }\n          ],\n          IsNotNever<RequiredActorOptions<TActor>>\n        >\n      : never)\n  | [\n      src: AnyActorLogic,\n      options?: SpawnActionOptions<\n        TContext,\n        TExpressionEvent,\n        TEvent,\n        ProvidedActor\n      > & { id?: never }\n    ];\n\ntype SpawnArguments<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  IsLiteralString<TActor['src']> extends true\n    ? DistributeActors<TContext, TExpressionEvent, TEvent, TActor>\n    : [\n        src: string | AnyActorLogic,\n        options?: {\n          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;\n          systemId?: string;\n          input?: unknown;\n          syncSnapshot?: boolean;\n        }\n      ];\n\nexport function spawnChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  ...[\n    src,\n    { id, systemId, input, syncSnapshot = false } = {} as any\n  ]: SpawnArguments<TContext, TExpressionEvent, TEvent, TActor>\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  function spawnChild(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n\n  return spawnChild;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus } from '../createActor.ts';\nimport {\n  ActionArgs,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | AnyActorRef\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => AnyActorRef | string);\n\nfunction resolveStop(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n): BuiltinActionResolution {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef: AnyActorRef | undefined =\n    typeof actorRefOrString === 'string'\n      ? snapshot.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children\n    }),\n    resolvedActorRef,\n    undefined\n  ];\n}\nfunction executeStop(\n  actorScope: AnyActorScope,\n  actorRef: AnyActorRef | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stopChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<TContext, TExpressionEvent, TParams, TEvent>\n): StopAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function stop(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nexport const stop = stopChild;\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyMachineSnapshot,\n  NoRequiredParams,\n  WithDynamicParams,\n  Identity,\n  Elements,\n  DoNotInfer\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\ntype SingleGuardArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuardArg\n> = [TGuardArg] extends [{ type: string }]\n  ? Identity<TGuardArg>\n  : [TGuardArg] extends [string]\n    ? TGuardArg\n    : GuardPredicate<TContext, TExpressionEvent, TParams, ParameterizedObject>;\n\ntype NormalizeGuardArg<TGuardArg> = TGuardArg extends { type: string }\n  ? Identity<TGuardArg> & { params: unknown }\n  : TGuardArg extends string\n    ? { type: TGuardArg; params: undefined }\n    : '_out_TGuard' extends keyof TGuardArg\n      ? TGuardArg['_out_TGuard'] & ParameterizedObject\n      : never;\n\ntype NormalizeGuardArgArray<TArg extends unknown[]> = Elements<{\n  [K in keyof TArg]: NormalizeGuardArg<TArg[K]>;\n}>;\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent>, params: TParams): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TParams, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject['params'],\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    snapshot: AnyMachineSnapshot,\n    guardArgs: GuardArgs<any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  snapshot: AnyMachineSnapshot,\n  _: GuardArgs<any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some((sn) => sn === target);\n  }\n\n  return snapshot.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined\n>(\n  stateValue: StateValue\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  TParams,\n  any // TODO: recheck if we could replace this with something better here\n> {\n  function stateIn() {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn;\n}\n\nfunction checkNot(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg\n>(\n  guard: SingleGuardArg<TContext, TExpressionEvent, unknown, TArg>\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArg<DoNotInfer<TArg>>\n> {\n  function not(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not;\n}\n\nfunction checkAnd(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) =>\n    evaluateGuard(guard, context, event, snapshot)\n  );\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function and(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and;\n}\n\nfunction checkOr(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function or(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  snapshot: AnyMachineSnapshot\n): boolean {\n  const { machine } = snapshot;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, snapshot);\n  }\n\n  const guardArgs = {\n    context,\n    event\n  };\n\n  const guardParams =\n    isInline || typeof guard === 'string'\n      ? undefined\n      : 'params' in guard\n        ? typeof guard.params === 'function'\n          ? guard.params({ context, event })\n          : guard.params\n        : undefined;\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    snapshot,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { MachineSnapshot, cloneMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { spawnChild } from './actions/spawnChild.ts';\nimport { stopChild } from './actions/stopChild.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { matchesEventDescriptor } from './utils.ts';\nimport {\n  ActionArgs,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyMachineSnapshot,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyTransitionConfig,\n  AnyActorScope,\n  ActionExecutor,\n  AnyStateMachine\n} from './types.ts';\nimport {\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toTransitionConfigArray,\n  isErrorActorEvent\n} from './utils.ts';\n\ntype StateNodeIterable<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyStateNodeIterable = StateNodeIterable<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nconst isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getAllStateNodes(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const nodeSet = new Set(stateNodes);\n\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach((sn) =>\n        nodeSet.add(sn)\n      );\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return nodeSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nfunction getAdjList<TContext extends MachineContext, TE extends EventObject>(\n  stateNodes: StateNodeIterable<TContext, TE>\n): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  stateNodes: AnyStateNodeIterable\n): StateValue {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  stateNodeSet: Set<AnyStateNode>,\n  stateNode: AnyStateNode\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && stateNodeSet.has(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(stateNodeSet, sn)\n    );\n  }\n\n  return stateNode.type === 'final';\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((eventDescriptor) =>\n        matchesEventDescriptor(receivedEventType, eventDescriptor)\n      )\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (delay: string | number) => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n\n    stateNode.entry.push(\n      raise(afterEvent, {\n        id: eventType,\n        delay\n      })\n    );\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = Object.keys(afterConfig).flatMap((delay) => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition =\n      typeof configTransition === 'string'\n        ? { target: configTransition }\n        : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map((transition) => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | string\n    | undefined\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  const resolvedTarget =\n    typeof _target === 'string'\n      ? stateNode.states[_target]\n      : _target\n        ? stateNode.states[_target.target]\n        : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n      `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`\n    );\n  }\n  const transition: InitialTransitionDefinition<TContext, TEvent> = {\n    source: stateNode,\n    actions:\n      !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null as any,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n\n  return transition;\n}\n\nfunction resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryDefaultTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }) {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial;\n  }\n  return {\n    target: normalizedTarget.map((t) =>\n      typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n    )\n  };\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nfunction getInitialStateNodesWithTheirAncestors(stateNode: AnyStateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\n\nexport function getInitialStateNodes(stateNode: AnyStateNode) {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode: AnyStateNode, stateKey: string): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode,\n  stateValue: StateValue\n): Array<AnyStateNode> {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(\n        `State '${stateValue}' does not exist on '${stateNode.id}'`\n      );\n    }\n    return [stateNode, childStateNode];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]!\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nfunction transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]]!,\n    snapshot,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      snapshot,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], stateNodeSet, historyValue),\n          computeExitSet([t2], stateNodeSet, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLeastCommonAncestor(\n  stateNodes: Array<AnyStateNode>\n): AnyStateNode | undefined {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every((sn) => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\n\nfunction getEffectiveTargetStates(\n  transition: Pick<AnyTransitionDefinition, 'target'>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          resolveHistoryDefaultTransition(targetNode),\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | undefined {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return;\n  }\n\n  if (\n    !transition.reenter &&\n    targetStates.every(\n      (target) =>\n        target === transition.source || isDescendant(target, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n\n  return transition.source.machine.root;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\nfunction areStateNodeCollectionsEqual(\n  prevStateNodes: StateNode[],\n  nextStateNodeSet: Set<StateNode>\n) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nexport function microstep(\n  transitions: Array<AnyTransitionDefinition>,\n  currentSnapshot: AnyMachineSnapshot,\n  actorScope: AnyActorScope,\n  event: AnyEventObject,\n  isInitial: boolean,\n  internalQueue: Array<AnyEventObject>\n): AnyMachineSnapshot {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(\n      nextState,\n      event,\n      actorScope,\n      filteredTransitions,\n      mutStateNodeSet,\n      historyValue,\n      internalQueue,\n      actorScope.actionExecutor\n    );\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions.flatMap((t) => t.actions),\n    internalQueue,\n    undefined\n  );\n\n  // Enter states\n  nextState = enterStates(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions,\n    mutStateNodeSet,\n    internalQueue,\n    historyValue,\n    isInitial\n  );\n\n  const nextStateNodes = [...mutStateNodeSet];\n\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(\n      nextState,\n      event,\n      actorScope,\n      nextStateNodes\n        .sort((a, b) => b.order - a.order)\n        .flatMap((state) => state.exit),\n      internalQueue,\n      undefined\n    );\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (\n      historyValue === currentSnapshot.historyValue &&\n      areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)\n    ) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction getMachineOutput(\n  snapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  rootNode: AnyStateNode,\n  rootCompletionNode: AnyStateNode\n) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(\n    rootCompletionNode.id,\n    rootCompletionNode.output !== undefined && rootCompletionNode.parent\n      ? resolveOutput(\n          rootCompletionNode.output,\n          snapshot.context,\n          event,\n          actorScope.self\n        )\n      : undefined\n  );\n  return resolveOutput(\n    rootNode.output,\n    snapshot.context,\n    doneStateEvent,\n    actorScope.self\n  );\n}\n\nfunction enterStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  internalQueue: AnyEventObject[],\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set<AnyStateNode>();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n\n  const completedNodes = new Set();\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions: UnknownAction[] = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(\n        spawnChild(invokeDef.src, {\n          ...invokeDef,\n          syncSnapshot: !!invokeDef.onSnapshot\n        })\n      );\n    }\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      actions,\n      internalQueue,\n      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)\n    );\n\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n\n      let ancestorMarker =\n        parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n\n      if (parent?.type === 'compound') {\n        internalQueue.push(\n          createDoneStateEvent(\n            parent.id,\n            stateNodeToEnter.output !== undefined\n              ? resolveOutput(\n                  stateNodeToEnter.output,\n                  nextSnapshot.context,\n                  event,\n                  actorScope.self\n                )\n              : undefined\n          )\n        );\n      }\n      while (\n        ancestorMarker?.type === 'parallel' &&\n        !completedNodes.has(ancestorMarker) &&\n        isInFinalState(mutStateNodeSet, ancestorMarker)\n      ) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(\n          nextSnapshot,\n          event,\n          actorScope,\n          nextSnapshot.machine.root,\n          rootCompletionNode\n        )\n      });\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n\n    for (const s of t.target || []) {\n      if (\n        !isHistoryNode(s) &&\n        // if the target is different than the source then it will *definitely* be entered\n        (t.source !== s ||\n          // we know that the domain can't lie within the source\n          // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n          t.source !== domain ||\n          // reentering transitions always enter the target, even if it's the source itself\n          t.reenter)\n      ) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry,\n        ancestors,\n        !t.source.parent && t.reenter ? undefined : domain\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition<\n        TContext,\n        TEvent\n      >(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(\n        initialState,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n\n      addProperAncestorStatesToEnter(\n        initialState,\n        stateNode,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  ancestors: AnyStateNode[],\n  reentrancyDomain?: AnyStateNode\n) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction addProperAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  addAncestorStatesToEnter(\n    statesToEnter,\n    historyValue,\n    statesForDefaultEntry,\n    getProperAncestors(stateNode, toStateNode)\n  );\n}\n\nfunction exitStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  transitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  internalQueue: AnyEventObject[],\n  _actionExecutor: ActionExecutor\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  let changedHistory: typeof historyValue | undefined;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= { ...historyValue };\n      changedHistory[historyNode.id] =\n        Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],\n      internalQueue,\n      undefined\n    );\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue] as const;\n}\n\nexport interface BuiltinAction {\n  (): void;\n  type: `xstate.${string}`;\n  resolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    actionArgs: ActionArgs<any, any, any>,\n    actionParams: ParameterizedObject['params'] | undefined,\n    action: unknown,\n    extra: unknown\n  ) => [\n    newState: AnyMachineSnapshot,\n    params: unknown,\n    actions?: UnknownAction[]\n  ];\n  retryResolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    params: unknown\n  ) => void;\n  execute: (actorScope: AnyActorScope, params: unknown) => void;\n}\n\nfunction getAction(machine: AnyStateMachine, actionType: string) {\n  return machine.implementations.actions[actionType];\n}\n\nfunction resolveAndExecuteActionsWithContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  extra: {\n    internalQueue: AnyEventObject[];\n    deferredActorIds: string[] | undefined;\n  },\n  retries: (readonly [BuiltinAction, unknown])[] | undefined\n): AnyMachineSnapshot {\n  const { machine } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n\n        getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n\n    const actionParams =\n      isInline || typeof action === 'string'\n        ? undefined\n        : 'params' in action\n          ? typeof action.params === 'function'\n            ? action.params({ context: intermediateSnapshot.context, event })\n            : action.params\n          : undefined;\n\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type:\n          typeof action === 'string'\n            ? action\n            : typeof action === 'object'\n              ? action.type\n              : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorScope,\n      intermediateSnapshot,\n      actionArgs,\n      actionParams,\n      resolvedAction, // this holds all params\n      extra\n    );\n    intermediateSnapshot = nextState;\n\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(\n        intermediateSnapshot,\n        event,\n        actorScope,\n        actions,\n        extra,\n        retries\n      );\n    }\n  }\n\n  return intermediateSnapshot;\n}\n\nexport function resolveActionsAndContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  deferredActorIds: string[] | undefined\n): AnyMachineSnapshot {\n  const retries: (readonly [BuiltinAction, unknown])[] | undefined =\n    deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(\n    currentSnapshot,\n    event,\n    actorScope,\n    actions,\n    { internalQueue, deferredActorIds },\n    retries\n  );\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\n\nexport function macrostep(\n  snapshot: AnyMachineSnapshot,\n  event: EventObject,\n  actorScope: AnyActorScope,\n  internalQueue: AnyEventObject[]\n): {\n  snapshot: typeof snapshot;\n  microstates: Array<typeof snapshot>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextSnapshot = snapshot;\n  const microstates: AnyMachineSnapshot[] = [];\n\n  function addMicrostate(\n    microstate: AnyMachineSnapshot,\n    event: AnyEventObject,\n    transitions: AnyTransitionDefinition[]\n  ) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(\n      stopChildren(nextSnapshot, event, actorScope),\n      {\n        status: 'stopped'\n      }\n    );\n    addMicrostate(nextSnapshot, event, []);\n\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot<typeof snapshot>(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(\n      transitions,\n      snapshot,\n      actorScope,\n      nextEvent,\n      false, // isInitial\n      internalQueue\n    );\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n\n  let shouldSelectEventlessTransitions = true;\n\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions: AnyTransitionDefinition[] =\n      shouldSelectEventlessTransitions\n        ? selectEventlessTransitions(nextSnapshot, nextEvent)\n        : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift()!;\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n\n    nextSnapshot = microstep(\n      enabledTransitions,\n      nextSnapshot,\n      actorScope,\n      nextEvent,\n      false,\n      internalQueue\n    );\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\n\nfunction stopChildren(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope\n) {\n  return resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    Object.values(nextState.children).map((child: any) => stopChild(child)),\n    [],\n    undefined\n  );\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyMachineSnapshot\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, undefined)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState._nodes),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n","import isDevelopment from '#is-development';\nimport { $$ACTOR_TYPE } from './createActor.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { getStateValue } from './stateUtils.ts';\nimport type {\n  ProvidedActor,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  StateConfig,\n  StateValue,\n  AnyActorRef,\n  Snapshot,\n  ParameterizedObject,\n  IsNever,\n  MetaObject,\n  StateSchema,\n  StateId,\n  SnapshotStatus,\n  PersistedHistoryValue\n} from './types.ts';\nimport { matchesState } from './utils.ts';\n\ntype ToTestStateValue<TStateValue extends StateValue> =\n  TStateValue extends string\n    ? TStateValue\n    : IsNever<keyof TStateValue> extends true\n      ? never\n      :\n          | keyof TStateValue\n          | {\n              [K in keyof TStateValue]?: ToTestStateValue<\n                NonNullable<TStateValue[K]>\n              >;\n            };\n\nexport function isMachineSnapshot(value: unknown): value is AnyMachineSnapshot {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'machine' in value &&\n    'value' in value\n  );\n}\n\ninterface MachineSnapshotBase<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta,\n  TStateSchema extends StateSchema = StateSchema\n> {\n  /** The state machine that produced this state snapshot. */\n  machine: StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    TStateValue,\n    TTag,\n    unknown,\n    TOutput,\n    EventObject, // TEmitted\n    any, // TMeta\n    TStateSchema\n  >;\n  /** The tags of the active state nodes that represent the current state value. */\n  tags: Set<string>;\n  /**\n   * The current state value.\n   *\n   * This represents the active state nodes in the state machine.\n   *\n   * - For atomic state nodes, it is a string.\n   * - For compound parent state nodes, it is an object where:\n   *\n   *   - The key is the parent state node's key\n   *   - The value is the current state value of the active child state node(s)\n   *\n   * @example\n   *\n   * ```ts\n   * // single-level state node\n   * snapshot.value; // => 'yellow'\n   *\n   * // nested state nodes\n   * snapshot.value; // => { red: 'wait' }\n   * ```\n   */\n  value: TStateValue;\n  /** The current status of this snapshot. */\n  status: SnapshotStatus;\n  error: unknown;\n  context: TContext;\n\n  historyValue: Readonly<HistoryValue<TContext, TEvent>>;\n  /** The enabled state nodes representative of the state value. */\n  _nodes: Array<StateNode<TContext, TEvent>>;\n  /** An object mapping actor names to spawned/invoked actors. */\n  children: TChildren;\n\n  /**\n   * Whether the current state value is a subset of the given partial state\n   * value.\n   *\n   * @param partialStateValue\n   */\n  matches: (partialStateValue: ToTestStateValue<TStateValue>) => boolean;\n\n  /**\n   * Whether the current state nodes has a state node with the specified `tag`.\n   *\n   * @param tag\n   */\n  hasTag: (tag: TTag) => boolean;\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden\n   * transition to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  can: (event: TEvent) => boolean;\n\n  getMeta: () => Record<\n    StateId<TStateSchema> & string,\n    TMeta | undefined // States might not have meta defined\n  >;\n\n  toJSON: () => unknown;\n}\n\ninterface ActiveMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'active';\n  output: undefined;\n  error: undefined;\n}\n\ninterface DoneMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'done';\n  output: TOutput;\n  error: undefined;\n}\n\ninterface ErrorMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'error';\n  output: undefined;\n  error: unknown;\n}\n\ninterface StoppedMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'stopped';\n  output: undefined;\n  error: undefined;\n}\n\nexport type MachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> =\n  | ActiveMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | DoneMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | ErrorMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | StoppedMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n\nconst machineSnapshotMatches = function matches(\n  this: AnyMachineSnapshot,\n  testValue: StateValue\n) {\n  return matchesState(testValue, this.value);\n};\n\nconst machineSnapshotHasTag = function hasTag(\n  this: AnyMachineSnapshot,\n  tag: string\n) {\n  return this.tags.has(tag);\n};\n\nconst machineSnapshotCan = function can(\n  this: AnyMachineSnapshot,\n  event: EventObject\n) {\n  if (isDevelopment && !this.machine) {\n    console.warn(\n      `state.can(...) used outside of a machine-created State object; this will always return false.`\n    );\n  }\n\n  const transitionData = this.machine.getTransitionData(this, event);\n\n  return (\n    !!transitionData?.length &&\n    // Check that at least one transition is not forbidden\n    transitionData.some((t) => t.target !== undefined || t.actions.length)\n  );\n};\n\nconst machineSnapshotToJSON = function toJSON(this: AnyMachineSnapshot) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return { ...jsonValues, tags: Array.from(tags) };\n};\n\nconst machineSnapshotGetMeta = function getMeta(this: AnyMachineSnapshot) {\n  return this._nodes.reduce(\n    (acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n};\n\nexport function createMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n>(\n  config: StateConfig<TContext, TEvent>,\n  machine: AnyStateMachine\n): MachineSnapshot<\n  TContext,\n  TEvent,\n  TChildren,\n  TStateValue,\n  TTag,\n  undefined,\n  TMeta,\n  TStateSchema\n> {\n  return {\n    status: config.status as never,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes) as never,\n    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),\n    children: config.children as any,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches as never,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\n\nexport function cloneMachineSnapshot<TState extends AnyMachineSnapshot>(\n  snapshot: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return createMachineSnapshot(\n    { ...snapshot, ...config } as StateConfig<any, any>,\n    snapshot.machine\n  ) as TState;\n}\n\nfunction serializeHistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(historyValue: HistoryValue<TContext, TEvent>): PersistedHistoryValue {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result: PersistedHistoryValue = {};\n\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map((item) => ({ id: item.id }));\n    }\n  }\n\n  return result;\n}\n\nexport function getPersistedSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject\n>(\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    any // state schema\n  >,\n  options?: unknown\n): Snapshot<unknown> {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n\n  const childrenJson: Record<string, unknown> = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    if (\n      isDevelopment &&\n      typeof child.src !== 'string' &&\n      (!options || !('__unsafeAllowInlineActors' in (options as object)))\n    ) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id as keyof typeof childrenJson] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child.systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context) as any,\n    children: childrenJson,\n    historyValue: serializeHistoryValue<TContext, TEvent>(\n      jsonValues.historyValue\n    )\n  };\n\n  return persisted;\n}\n\nfunction persistContext(contextPart: Record<string, unknown>) {\n  let copy: typeof contextPart | undefined;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart)\n          ? (contextPart.slice() as typeof contextPart)\n          : { ...contextPart };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: (value as any as AnyActorRef).id\n        };\n      } else {\n        const result = persistContext(value as typeof contextPart);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart)\n            ? (contextPart.slice() as typeof contextPart)\n            : { ...contextPart };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n","import { ProcessingStatus, createActor } from './createActor.ts';\nimport {\n  ActorRefFromLogic,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  GetConcreteByKey,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  ProvidedActor,\n  RequiredActorOptions,\n  TODO,\n  type RequiredLogicInput\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? ConditionalRequired<\n      [\n        options?: {\n          id?: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        } & { [K in RequiredActorOptions<TActor>]: unknown }\n      ],\n      IsNotNever<RequiredActorOptions<TActor>>\n    >\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> =\n  IsLiteralString<TActor['src']> extends true\n    ? {\n        <TSrc extends TActor['src']>(\n          logic: TSrc,\n          ...[options]: SpawnOptions<TActor, TSrc>\n        ): ActorRefFromLogic<GetConcreteByKey<TActor, 'src', TSrc>['logic']>;\n        <TLogic extends AnyActorLogic>(\n          src: TLogic,\n          ...[options]: ConditionalRequired<\n            [\n              options?: {\n                id?: never;\n                systemId?: string;\n                input?: InputFrom<TLogic>;\n                syncSnapshot?: boolean;\n              } & { [K in RequiredLogicInput<TLogic>]: unknown }\n            ],\n            IsNotNever<RequiredLogicInput<TLogic>>\n          >\n        ): ActorRefFromLogic<TLogic>;\n      }\n    : <TLogic extends AnyActorLogic | string>(\n        src: TLogic,\n        ...[options]: ConditionalRequired<\n          [\n            options?: {\n              id?: string;\n              systemId?: string;\n              input?: TLogic extends string ? unknown : InputFrom<TLogic>;\n              syncSnapshot?: boolean;\n            } & (TLogic extends AnyActorLogic\n              ? { [K in RequiredLogicInput<TLogic>]: unknown }\n              : {})\n          ],\n          IsNotNever<\n            TLogic extends AnyActorLogic ? RequiredLogicInput<TLogic> : never\n          >\n        >\n      ) => TLogic extends AnyActorLogic\n        ? ActorRefFromLogic<TLogic>\n        : AnyActorRef;\n\nexport function createSpawner(\n  actorScope: AnyActorScope,\n  { machine, context }: AnyMachineSnapshot,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = ((src, options) => {\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n\n      if (!logic) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const actorRef = createActor(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input:\n          typeof options?.input === 'function'\n            ? options.input({\n                context,\n                event,\n                self: actorScope.self\n              })\n            : options?.input,\n        src,\n        systemId: options?.systemId\n      }) as any;\n\n      spawnedChildren[actorRef.id] = actorRef;\n\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n\n      return actorRef;\n    }\n  }) as Spawner<any>;\n  return ((src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  }) as Spawner<any>;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { executingCustomAction } from '../createActor.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorScope,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor,\n  ActionFunction,\n  BuiltinActionResolution\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n): BuiltinActionResolution {\n  if (!snapshot.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any> = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(\n      actorScope,\n      snapshot,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs, actionParams)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n\n  return [\n    cloneMachineSnapshot(snapshot, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...snapshot.children,\n            ...spawnedChildren\n          }\n        : snapshot.children\n    }),\n    undefined,\n    undefined\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  assignment:\n    | Assigner<LowInfer<TContext>, TExpressionEvent, TParams, TEvent, TActor>\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TParams,\n        TEvent,\n        TActor\n      >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function assign(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import isDevelopment from '#is-development';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  DoNotInfer,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  SendExpr,\n  BuiltinActionResolution\n} from '../types.ts';\n\nfunction resolveEmit(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    event: eventOrExpr\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n  }\n): BuiltinActionResolution {\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n  return [snapshot, { event: resolvedEvent }, undefined];\n}\n\nfunction executeEmit(\n  actorScope: AnyActorScope,\n  {\n    event\n  }: {\n    event: EventObject;\n  }\n) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n\nexport interface EmitAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TEmitted extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEmitted?: TEmitted;\n}\n\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nexport function emit<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TEmitted extends AnyEventObject\n>(\n  /** The event to emit, or an expression that returns an event to emit. */\n  eventOrExpr:\n    | DoNotInfer<TEmitted>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TParams,\n        DoNotInfer<TEmitted>,\n        TEvent\n      >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  never,\n  TEmitted\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function emit(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n\n  return emit;\n}\n","import isDevelopment from '#is-development';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  DelayExpr,\n  DoNotInfer,\n  EventObject,\n  ExecutableActionObject,\n  MachineContext,\n  ParameterizedObject,\n  RaiseActionOptions,\n  SendExpr,\n  BuiltinActionResolution\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject\n        >\n      | undefined;\n  },\n  { internalQueue }: { internalQueue: AnyEventObject[] }\n): BuiltinActionResolution {\n  const delaysMap = snapshot.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function'\n        ? configDelay(args, actionParams)\n        : configDelay;\n  } else {\n    resolvedDelay =\n      typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [\n    snapshot,\n    {\n      event: resolvedEvent,\n      id,\n      delay: resolvedDelay\n    },\n    undefined\n  ];\n}\n\nfunction executeRaise(\n  actorScope: AnyActorScope,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  const { event, delay, id } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  eventOrExpr:\n    | DoNotInfer<TEvent>\n    | SendExpr<TContext, TExpressionEvent, TParams, DoNotInfer<TEvent>, TEvent>,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    DoNotInfer<TEvent>,\n    TUsedDelay\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  TDelay,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function raise(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n\nexport interface ExecutableRaiseAction extends ExecutableActionObject {\n  type: 'xstate.raise';\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  };\n}\n","import type { MachineSnapshot } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { AssignArgs } from './actions/assign.ts';\nimport { ExecutableRaiseAction } from './actions/raise.ts';\nimport { ExecutableSendToAction } from './actions/send.ts';\nimport { PromiseActorLogic } from './actors/promise.ts';\nimport type { Actor, ProcessingStatus } from './createActor.ts';\nimport { Guard, GuardPredicate, UnknownGuard } from './guards.ts';\nimport { InspectionEvent } from './inspection.ts';\nimport { Spawner } from './spawn.ts';\nimport { AnyActorSystem, Clock } from './system.ts';\n\n// this is needed to make JSDoc `@link` work properly\nimport type { SimulatedClock } from './SimulatedClock.ts';\n\nexport type Identity<T> = { [K in keyof T]: T[K] };\n\nexport type HomomorphicPick<T, K extends keyof any> = {\n  [P in keyof T as P & K]: T[P];\n};\nexport type HomomorphicOmit<T, K extends keyof any> = {\n  [P in keyof T as Exclude<P, K>]: T[P];\n};\n\nexport type Invert<T extends Record<PropertyKey, PropertyKey>> = {\n  [K in keyof T as T[K]]: K;\n};\n\nexport type GetParameterizedParams<T extends ParameterizedObject | undefined> =\n  T extends any ? ('params' extends keyof T ? T['params'] : undefined) : never;\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\nexport type NonReducibleUnknown = {} | null | undefined;\nexport type AnyFunction = (...args: any[]) => any;\n\ntype ReturnTypeOrValue<T> = T extends AnyFunction ? ReturnType<T> : T;\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\nexport type IsNever<T> = [T] extends [never] ? true : false;\nexport type IsNotNever<T> = [T] extends [never] ? false : true;\n\nexport type Compute<A> = { [K in keyof A]: A[K] } & unknown;\nexport type Prop<T, K> = K extends keyof T ? T[K] : never;\nexport type Values<T> = T[keyof T];\nexport type Elements<T> = T[keyof T & `${number}`];\nexport type Merge<M, N> = Omit<M, keyof N> & N;\nexport type IndexByProp<T extends Record<P, string>, P extends keyof T> = {\n  [E in T as E[P]]: E;\n};\n\nexport type IndexByType<T extends { type: string }> = IndexByProp<T, 'type'>;\n\nexport type Equals<A1, A2> =\n  (<A>() => A extends A2 ? true : false) extends <A>() => A extends A1\n    ? true\n    : false\n    ? true\n    : false;\nexport type IsAny<T> = Equals<T, any>;\nexport type Cast<A, B> = A extends B ? A : B;\n// @TODO: we can't use native `NoInfer` as we need those:\n// https://github.com/microsoft/TypeScript/pull/61092\n// https://github.com/microsoft/TypeScript/pull/61077\n// but even with those fixes native NoInfer still doesn't work - further issues have to be reproduced and fixed\nexport type DoNotInfer<T> = [T][T extends any ? 0 : any];\n/** @deprecated Use the built-in `NoInfer` type instead */\nexport type NoInfer<T> = DoNotInfer<T>;\nexport type LowInfer<T> = T & NonNullable<unknown>;\n\nexport type MetaObject = Record<string, any>;\n\nexport type Lazy<T> = () => T;\nexport type MaybeLazy<T> = T | Lazy<T>;\n\n/** The full definition of an event, with a string `type`. */\nexport type EventObject = {\n  /** The type of event that is sent. */\n  type: string;\n};\n\nexport interface AnyEventObject extends EventObject {\n  [key: string]: any;\n}\n\nexport interface ParameterizedObject {\n  type: string;\n  params?: NonReducibleUnknown;\n}\n\nexport interface UnifiedArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      Record<string, AnyActorRef | undefined>, // TODO: this should be replaced with `TChildren`\n      StateValue,\n      string,\n      unknown,\n      TODO, // TMeta\n      TODO // State schema\n    >,\n    TEvent,\n    AnyEventObject\n  >;\n  system: AnyActorSystem;\n}\n\nexport type MachineContext = Record<string, any>;\n\nexport interface ActionArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject\n> extends UnifiedArg<TContext, TExpressionEvent, TEvent> {}\n\nexport type InputFrom<T> =\n  T extends StateMachine<\n    infer _TContext,\n    infer _TEvent,\n    infer _TChildren,\n    infer _TActor,\n    infer _TAction,\n    infer _TGuard,\n    infer _TDelay,\n    infer _TStateValue,\n    infer _TTag,\n    infer TInput,\n    infer _TOutput,\n    infer _TEmitted,\n    infer _TMeta,\n    infer _TStateSchema\n  >\n    ? TInput\n    : T extends ActorLogic<\n          infer _TSnapshot,\n          infer _TEvent,\n          infer TInput,\n          infer _TSystem,\n          infer _TEmitted\n        >\n      ? TInput\n      : never;\n\nexport type OutputFrom<T> =\n  T extends ActorLogic<\n    infer TSnapshot,\n    infer _TEvent,\n    infer _TInput,\n    infer _TSystem,\n    infer _TEmitted\n  >\n    ? (TSnapshot & { status: 'done' })['output']\n    : T extends ActorRef<infer TSnapshot, infer _TEvent, infer _TEmitted>\n      ? (TSnapshot & { status: 'done' })['output']\n      : never;\n\nexport type ActionFunction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> = {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent; // TODO: it feels like we should be able to remove this since now `TEvent` is \"observable\" by `self`\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n  _out_TEmitted?: TEmitted;\n};\n\nexport type NoRequiredParams<T extends ParameterizedObject> = T extends any\n  ? undefined extends T['params']\n    ? T['type']\n    : never\n  : never;\n\nexport type ConditionalRequired<\n  T,\n  Condition extends boolean\n> = Condition extends true ? Required<T> : T;\n\nexport type WithDynamicParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  T extends ParameterizedObject\n> = T extends any\n  ? ConditionalRequired<\n      {\n        type: T['type'];\n        params?:\n          | T['params']\n          | (({\n              context,\n              event\n            }: {\n              context: TContext;\n              event: TExpressionEvent;\n            }) => T['params']);\n      },\n      undefined extends T['params'] ? false : true\n    >\n  : never;\n\nexport type Action<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> =\n  // TODO: consider merging `NoRequiredParams` and `WithDynamicParams` into one\n  // this way we could iterate over `TAction` (and `TGuard` in the `Guard` type) once and not twice\n  | NoRequiredParams<TAction>\n  | WithDynamicParams<TContext, TExpressionEvent, TAction>\n  | ActionFunction<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TParams,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TEmitted\n    >;\n\nexport type UnknownAction = Action<\n  MachineContext,\n  EventObject,\n  EventObject,\n  ParameterizedObject['params'] | undefined,\n  ProvidedActor,\n  ParameterizedObject,\n  ParameterizedObject,\n  string,\n  EventObject\n>;\n\nexport type Actions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> = SingleOrArray<\n  Action<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    TParams,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >\n>;\n\nexport type StateKey = string | AnyMachineSnapshot;\n\nexport interface StateValueMap {\n  [key: string]: StateValue | undefined;\n}\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\nexport type StateValue = string | StateValueMap;\n\nexport type TransitionTarget = SingleOrArray<string>;\n\nexport interface TransitionConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject = EventObject,\n  TMeta extends MetaObject = MetaObject\n> {\n  guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;\n  actions?: Actions<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >;\n  reenter?: boolean;\n  target?: TransitionTarget | undefined;\n  meta?: TMeta;\n  description?: string;\n}\n\nexport interface InitialTransitionConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> extends TransitionConfig<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TODO, // TEmitted\n    TODO // TMeta\n  > {\n  target: string;\n}\n\nexport type AnyTransitionConfig = TransitionConfig<\n  any, // TContext\n  any, // TExpressionEvent\n  any, // TEvent\n  any, // TActor\n  any, // TAction\n  any, // TGuard\n  any, // TDelay\n  any, // TEmitted\n  any // TMeta\n>;\n\nexport interface InvokeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> {\n  id: string;\n\n  systemId: string | undefined;\n  /** The source of the actor logic to be invoked */\n  src: AnyActorLogic | string;\n\n  input?:\n    | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n    | NonReducibleUnknown;\n  /**\n   * The transition to take upon the invoked child machine reaching its final\n   * top-level state.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneActorEvent<unknown>,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TEmitted,\n          TMeta\n        >\n      >;\n  /**\n   * The transition to take upon the invoked child machine sending an error\n   * event.\n   */\n  onError?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          ErrorActorEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TEmitted,\n          TMeta\n        >\n      >;\n\n  onSnapshot?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          SnapshotEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TEmitted,\n          TMeta\n        >\n      >;\n\n  toJSON: () => Omit<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TEmitted,\n      TMeta\n    >,\n    'onDone' | 'onError' | 'toJSON'\n  >;\n}\n\ntype Delay<TDelay extends string> = TDelay | number;\n\nexport type DelayedTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = {\n  [K in Delay<TDelay>]?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          TEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TODO, // TEmitted\n          TODO // TMeta\n        >\n      >;\n};\n\nexport type StateTypes =\n  | 'atomic'\n  | 'compound'\n  | 'parallel'\n  | 'final'\n  | 'history'\n  | ({} & string);\n\nexport type SingleOrArray<T> = readonly T[] | T;\n\nexport type StateNodesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNode<TContext, TEvent>;\n};\n\nexport type StatesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> = {\n  [K in string]: StateNodeConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TOutput,\n    TEmitted,\n    TMeta\n  >;\n};\n\nexport type StatesDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNodeDefinition<TContext, TEvent>;\n};\n\nexport type TransitionConfigTarget = string | undefined;\n\nexport type TransitionConfigOrTarget<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> = SingleOrArray<\n  | TransitionConfigTarget\n  | TransitionConfig<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TEmitted,\n      TMeta\n    >\n>;\n\nexport type TransitionsConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> = {\n  [K in EventDescriptor<TEvent>]?: TransitionConfigOrTarget<\n    TContext,\n    ExtractEvent<TEvent, K>,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted,\n    TMeta\n  >;\n};\n\ntype PartialEventDescriptor<TEventType extends string> =\n  TEventType extends `${infer TLeading}.${infer TTail}`\n    ? `${TLeading}.*` | `${TLeading}.${PartialEventDescriptor<TTail>}`\n    : never;\n\nexport type EventDescriptor<TEvent extends EventObject> =\n  | TEvent['type']\n  | PartialEventDescriptor<TEvent['type']>\n  | '*';\n\ntype NormalizeDescriptor<TDescriptor extends string> = TDescriptor extends '*'\n  ? string\n  : TDescriptor extends `${infer TLeading}.*`\n    ? `${TLeading}.${string}`\n    : TDescriptor;\n\nexport type IsLiteralString<T extends string> = string extends T ? false : true;\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  TSpecificActor extends ProvidedActor\n> = TSpecificActor extends { src: infer TSrc }\n  ?\n      | Compute<\n          {\n            systemId?: string;\n            /** The source of the machine to be invoked, or the machine itself. */\n            src: TSrc;\n\n            /**\n             * The unique identifier for the invoked machine. If not specified,\n             * this will be the machine's own `id`, or the URL (from `src`).\n             */\n            id?: TSpecificActor['id'];\n\n            // TODO: currently we do not enforce required inputs here\n            // in a sense, we shouldn't - they could be provided within the `implementations` object\n            // how do we verify if the required input has been provided?\n            input?:\n              | Mapper<\n                  TContext,\n                  TEvent,\n                  InputFrom<TSpecificActor['logic']>,\n                  TEvent\n                >\n              | InputFrom<TSpecificActor['logic']>;\n            /**\n             * The transition to take upon the invoked child machine reaching\n             * its final top-level state.\n             */\n            onDone?:\n              | string\n              | SingleOrArray<\n                  TransitionConfigOrTarget<\n                    TContext,\n                    DoneActorEvent<OutputFrom<TSpecificActor['logic']>>,\n                    TEvent,\n                    TActor,\n                    TAction,\n                    TGuard,\n                    TDelay,\n                    TEmitted,\n                    TMeta\n                  >\n                >;\n            /**\n             * The transition to take upon the invoked child machine sending an\n             * error event.\n             */\n            onError?:\n              | string\n              | SingleOrArray<\n                  TransitionConfigOrTarget<\n                    TContext,\n                    ErrorActorEvent,\n                    TEvent,\n                    TActor,\n                    TAction,\n                    TGuard,\n                    TDelay,\n                    TEmitted,\n                    TMeta\n                  >\n                >;\n\n            onSnapshot?:\n              | string\n              | SingleOrArray<\n                  TransitionConfigOrTarget<\n                    TContext,\n                    SnapshotEvent<SnapshotFrom<TSpecificActor['logic']>>,\n                    TEvent,\n                    TActor,\n                    TAction,\n                    TGuard,\n                    TDelay,\n                    TEmitted,\n                    TMeta\n                  >\n                >;\n          } & { [K in RequiredActorOptions<TSpecificActor>]: unknown }\n        >\n      | {\n          id?: never;\n          systemId?: string;\n          src: AnyActorLogic;\n          input?:\n            | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n            | NonReducibleUnknown;\n          onDone?:\n            | string\n            | SingleOrArray<\n                TransitionConfigOrTarget<\n                  TContext,\n                  DoneActorEvent<unknown>,\n                  TEvent,\n                  TActor,\n                  TAction,\n                  TGuard,\n                  TDelay,\n                  TEmitted,\n                  TMeta\n                >\n              >;\n          onError?:\n            | string\n            | SingleOrArray<\n                TransitionConfigOrTarget<\n                  TContext,\n                  ErrorActorEvent,\n                  TEvent,\n                  TActor,\n                  TAction,\n                  TGuard,\n                  TDelay,\n                  TEmitted,\n                  TMeta\n                >\n              >;\n\n          onSnapshot?:\n            | string\n            | SingleOrArray<\n                TransitionConfigOrTarget<\n                  TContext,\n                  SnapshotEvent,\n                  TEvent,\n                  TActor,\n                  TAction,\n                  TGuard,\n                  TDelay,\n                  TEmitted,\n                  TMeta\n                >\n              >;\n        }\n  : never;\n\nexport type InvokeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> =\n  IsLiteralString<TActor['src']> extends true\n    ? DistributeActors<\n        TContext,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TEmitted,\n        TMeta,\n        TActor\n      >\n    : {\n        /**\n         * The unique identifier for the invoked machine. If not specified, this\n         * will be the machine's own `id`, or the URL (from `src`).\n         */\n        id?: string;\n\n        systemId?: string;\n        /** The source of the machine to be invoked, or the machine itself. */\n        src: AnyActorLogic | string; // TODO: fix types\n\n        input?:\n          | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n          | NonReducibleUnknown;\n        /**\n         * The transition to take upon the invoked child machine reaching its\n         * final top-level state.\n         */\n        onDone?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                DoneActorEvent<any>, // TODO: consider replacing with `unknown`\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay,\n                TEmitted,\n                TMeta\n              >\n            >;\n        /**\n         * The transition to take upon the invoked child machine sending an\n         * error event.\n         */\n        onError?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                ErrorActorEvent,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay,\n                TEmitted,\n                TMeta\n              >\n            >;\n\n        onSnapshot?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                SnapshotEvent,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay,\n                TEmitted,\n                TMeta\n              >\n            >;\n      };\n\nexport type AnyInvokeConfig = InvokeConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any // TMeta\n>;\n\nexport interface StateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  _TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> {\n  /** The initial state transition. */\n  initial?:\n    | InitialTransitionConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>\n    | string\n    | undefined;\n  /**\n   * The type of this state node:\n   *\n   * - `'atomic'` - no child state nodes\n   * - `'compound'` - nested child state nodes (XOR)\n   * - `'parallel'` - orthogonal nested child state nodes (AND)\n   * - `'history'` - history state node\n   * - `'final'` - final state node\n   */\n  type?: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /**\n   * Indicates whether the state node is a history state node, and what type of\n   * history: shallow, deep, true (shallow), false (none), undefined (none)\n   */\n  history?: 'shallow' | 'deep' | boolean | undefined;\n  /**\n   * The mapping of state node keys to their state node configurations\n   * (recursive).\n   */\n  states?:\n    | StatesConfig<\n        TContext,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        NonReducibleUnknown,\n        TEmitted,\n        TMeta\n      >\n    | undefined;\n  /**\n   * The services to invoke upon entering this state node. These services will\n   * be stopped upon exiting this state node.\n   */\n  invoke?: SingleOrArray<\n    InvokeConfig<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TEmitted,\n      TMeta\n    >\n  >;\n  /** The mapping of event types to their potential transition(s). */\n  on?: TransitionsConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted,\n    TMeta\n  >;\n  /** The action(s) to be executed upon entering the state node. */\n  entry?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >;\n  /** The action(s) to be executed upon exiting the state node. */\n  exit?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >;\n  /**\n   * The potential transition(s) to be taken upon reaching a final child state\n   * node.\n   *\n   * This is equivalent to defining a `[done(id)]` transition on this state\n   * node's `on` property.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneStateEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TEmitted,\n          TMeta\n        >\n      >\n    | undefined;\n  /**\n   * The mapping (or array) of delays (in milliseconds) to their potential\n   * transition(s). The delayed transitions are taken after the specified delay\n   * in an interpreter.\n   */\n  after?: DelayedTransitions<TContext, TEvent, TActor, TAction, TGuard, TDelay>;\n\n  /**\n   * An eventless transition that is always taken when this state node is\n   * active.\n   */\n  always?: TransitionConfigOrTarget<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted,\n    TMeta\n  >;\n  parent?: StateNode<TContext, TEvent>;\n  /**\n   * The meta data associated with this state node, which will be returned in\n   * State instances.\n   */\n  meta?: TMeta;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a\n   * final state node.\n   *\n   * The output data will be evaluated with the current `context` and placed on\n   * the `.data` property of the event.\n   */\n  output?: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n  /**\n   * The unique ID of the state node, which can be referenced as a transition\n   * target via the `#id` syntax.\n   */\n  id?: string | undefined;\n  /**\n   * The order this state node appears. Corresponds to the implicit document\n   * order.\n   */\n  order?: number;\n\n  /**\n   * The tags for this state node, which are accumulated into the `state.tags`\n   * property.\n   */\n  tags?: SingleOrArray<TTag>;\n  /** A text description of the state node */\n  description?: string;\n\n  /** A default target for a history state */\n  target?: string | undefined; // `| undefined` makes `HistoryStateNodeConfig` compatible with this interface (it extends it) under `exactOptionalPropertyTypes`\n}\n\nexport type AnyStateNodeConfig = StateNodeConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any, // emitted\n  any // meta\n>;\n\nexport interface StateNodeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  id: string;\n  version?: string | undefined;\n  key: string;\n  type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  initial: InitialTransitionDefinition<TContext, TEvent> | undefined;\n  history: boolean | 'shallow' | 'deep' | undefined;\n  states: StatesDefinition<TContext, TEvent>;\n  on: TransitionDefinitionMap<TContext, TEvent>;\n  transitions: Array<TransitionDefinition<TContext, TEvent>>;\n  // TODO: establish what a definition really is\n  entry: UnknownAction[];\n  exit: UnknownAction[];\n  meta: any;\n  order: number;\n  output?: StateNodeConfig<\n    TContext,\n    TEvent,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    string,\n    unknown,\n    EventObject, // TEmitted\n    any // TMeta\n  >['output'];\n  invoke: Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      TODO,\n      TODO,\n      TODO,\n      TODO,\n      TODO, // TEmitted\n      TODO // TMeta\n    >\n  >;\n  description?: string;\n  tags: string[];\n}\n\nexport interface StateMachineDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeDefinition<TContext, TEvent> {}\n\nexport type AnyStateNode = StateNode<any, any>;\n\nexport type AnyStateNodeDefinition = StateNodeDefinition<any, any>;\n\nexport type AnyMachineSnapshot = MachineSnapshot<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\nexport type AnyState = AnyMachineSnapshot;\n\nexport type AnyStateMachine = StateMachine<\n  any, // context\n  any, // event\n  any, // children\n  any, // actor\n  any, // action\n  any, // guard\n  any, // delay\n  any, // state value\n  any, // tag\n  any, // input\n  any, // output\n  any, // emitted\n  any, // TMeta\n  any // TStateSchema\n>;\n\nexport type AnyStateConfig = StateConfig<any, AnyEventObject>;\n\nexport interface AtomicStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeConfig<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO, // emitted\n    TODO // meta\n  > {\n  initial?: undefined;\n  parallel?: false | undefined;\n  states?: undefined;\n  onDone?: undefined;\n}\n\nexport interface HistoryStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends AtomicStateNodeConfig<TContext, TEvent> {\n  history: 'shallow' | 'deep' | true;\n  target: string | undefined;\n}\n\nexport type SimpleOrStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> =\n  | AtomicStateNodeConfig<TContext, TEvent>\n  | StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO,\n      TODO,\n      TODO,\n      TODO,\n      TODO,\n      TODO,\n      TODO, // emitted\n      TODO // meta\n    >;\n\nexport type ActionFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TEmitted extends EventObject = EventObject\n> = {\n  [K in TAction['type']]?: ActionFunction<\n    TContext,\n    TEvent,\n    TEvent,\n    GetParameterizedParams<TAction extends { type: K } ? TAction : never>,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >;\n};\n\ntype GuardMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TGuard extends ParameterizedObject\n> = {\n  [K in TGuard['type']]?: GuardPredicate<\n    TContext,\n    TEvent,\n    GetParameterizedParams<TGuard extends { type: K } ? TGuard : never>,\n    TGuard\n  >;\n};\n\nexport type DelayFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TAction extends ParameterizedObject\n> = Record<string, DelayConfig<TContext, TEvent, TAction['params'], TEvent>>;\n\nexport type DelayConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> = number | DelayExpr<TContext, TExpressionEvent, TParams, TEvent>;\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\nexport interface MachineImplementationsSimplified<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject\n> {\n  guards: GuardMap<TContext, TEvent, TGuard>;\n  actions: ActionFunctionMap<TContext, TEvent, TActor, TAction>;\n  actors: Record<\n    string,\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n      }\n  >;\n  delays: DelayFunctionMap<TContext, TEvent, TAction>;\n}\n\ntype MachineImplementationsActions<TTypes extends StateMachineTypes> = {\n  [K in TTypes['actions']['type']]?: ActionFunction<\n    TTypes['context'],\n    TTypes['events'],\n    TTypes['events'],\n    GetConcreteByKey<TTypes['actions'], 'type', K>['params'],\n    TTypes['actors'],\n    TTypes['actions'],\n    TTypes['guards'],\n    TTypes['delays'],\n    TTypes['emitted']\n  >;\n};\n\ntype MachineImplementationsActors<TTypes extends StateMachineTypes> = {\n  [K in TTypes['actors']['src']]?: GetConcreteByKey<\n    TTypes['actors'],\n    'src',\n    K\n  >['logic'];\n};\n\ntype MachineImplementationsDelays<TTypes extends StateMachineTypes> = {\n  [K in TTypes['delays']]?: DelayConfig<\n    TTypes['context'],\n    TTypes['events'],\n    // delays in referenced send actions might use specific `TAction`\n    // delays executed by auto-generated send actions related to after transitions won't have that\n    // since they are effectively implicit inline actions\n    undefined,\n    TTypes['events']\n  >;\n};\n\ntype MachineImplementationsGuards<TTypes extends StateMachineTypes> = {\n  [K in TTypes['guards']['type']]?: Guard<\n    TTypes['context'],\n    TTypes['events'],\n    GetConcreteByKey<TTypes['guards'], 'type', K>['params'],\n    TTypes['guards']\n  >;\n};\n\nexport type InternalMachineImplementations<TTypes extends StateMachineTypes> = {\n  actions?: MachineImplementationsActions<TTypes>;\n  actors?: MachineImplementationsActors<TTypes>;\n  delays?: MachineImplementationsDelays<TTypes>;\n  guards?: MachineImplementationsGuards<TTypes>;\n};\n\ntype InitialContext<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput,\n  TEvent extends EventObject\n> = TContext | ContextFactory<TContext, TActor, TInput, TEvent>;\n\nexport type ContextFactory<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput,\n  TEvent extends EventObject = EventObject\n> = ({\n  spawn,\n  input,\n  self\n}: {\n  spawn: Spawner<TActor>;\n  input: TInput;\n  self: ActorRef<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      Record<string, AnyActorRef | undefined>, // TODO: this should be replaced with `TChildren`\n      StateValue,\n      string,\n      unknown,\n      TODO, // TMeta\n      TODO // State schema\n    >,\n    TEvent,\n    AnyEventObject\n  >;\n}) => TContext;\n\nexport type MachineConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TTag extends string = string,\n  TInput = any,\n  TOutput = unknown,\n  TEmitted extends EventObject = EventObject,\n  TMeta extends MetaObject = MetaObject\n> = (Omit<\n  StateNodeConfig<\n    DoNotInfer<TContext>,\n    DoNotInfer<TEvent>,\n    DoNotInfer<TActor>,\n    DoNotInfer<TAction>,\n    DoNotInfer<TGuard>,\n    DoNotInfer<TDelay>,\n    DoNotInfer<TTag>,\n    DoNotInfer<TOutput>,\n    DoNotInfer<TEmitted>,\n    DoNotInfer<TMeta>\n  >,\n  'output'\n> & {\n  /** The initial context (extended state) */\n  /** The machine's own version. */\n  version?: string;\n  // TODO: make it conditionally required\n  output?: Mapper<TContext, DoneStateEvent, TOutput, TEvent> | TOutput;\n}) &\n  (MachineContext extends TContext\n    ? { context?: InitialContext<LowInfer<TContext>, TActor, TInput, TEvent> }\n    : { context: InitialContext<LowInfer<TContext>, TActor, TInput, TEvent> });\n\nexport type UnknownMachineConfig = MachineConfig<MachineContext, EventObject>;\n\nexport interface ProvidedActor {\n  src: string;\n  logic: UnknownActorLogic;\n  id?: string | undefined; // `| undefined` is required here for compatibility with `exactOptionalPropertyTypes`, see #4613\n}\n\nexport interface SetupTypes<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildrenMap extends Record<string, string>,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> {\n  context?: TContext;\n  events?: TEvent;\n  children?: TChildrenMap;\n  tags?: TTag;\n  input?: TInput;\n  output?: TOutput;\n  emitted?: TEmitted;\n  meta?: TMeta;\n}\n\nexport interface MachineTypes<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> extends SetupTypes<\n    TContext,\n    TEvent,\n    // in machine types we currently don't support `TChildren`\n    // and IDs can still be configured through `TActor['id']`\n    never,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta\n  > {\n  actors?: TActor;\n  actions?: TAction;\n  guards?: TGuard;\n  delays?: TDelay;\n  meta?: TMeta;\n}\n\nexport interface HistoryStateNode<TContext extends MachineContext>\n  extends StateNode<TContext> {\n  history: 'shallow' | 'deep';\n  target: string | undefined;\n}\n\nexport type HistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Record<string, Array<StateNode<TContext, TEvent>>>;\n\nexport type PersistedHistoryValue = Record<string, Array<{ id: string }>>;\n\nexport type AnyHistoryValue = HistoryValue<any, any>;\n\nexport type StateFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> = T extends AnyStateMachine\n  ? ReturnType<T['transition']>\n  : T extends (...args: any[]) => AnyStateMachine\n    ? ReturnType<ReturnType<T>['transition']>\n    : never;\n\nexport type Transitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Array<TransitionDefinition<TContext, TEvent>>;\n\nexport interface DoneActorEvent<TOutput = unknown, TId extends string = string>\n  extends EventObject {\n  type: `xstate.done.actor.${TId}`;\n  output: TOutput;\n  actorId: TId;\n}\n\nexport interface ErrorActorEvent<\n  TErrorData = unknown,\n  TId extends string = string\n> extends EventObject {\n  type: `xstate.error.actor.${TId}`;\n  error: TErrorData;\n  actorId: TId;\n}\n\nexport interface SnapshotEvent<\n  TSnapshot extends Snapshot<unknown> = Snapshot<unknown>\n> extends EventObject {\n  type: `xstate.snapshot.${string}`;\n  snapshot: TSnapshot;\n}\n\nexport interface DoneStateEvent<TOutput = unknown> extends EventObject {\n  type: `xstate.done.state.${string}`;\n  output: TOutput;\n}\n\nexport type DelayExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n  params: TParams\n) => number;\n\nexport type LogExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n  params: TParams\n) => unknown;\n\nexport type SendExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n  params: TParams\n) => TSentEvent;\n\nexport enum SpecialTargets {\n  Parent = '#_parent',\n  Internal = '#_internal'\n}\n\nexport interface SendToActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TDelay\n  > {}\n\nexport interface RaiseActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  id?: string;\n  delay?:\n    | Delay<TDelay>\n    | DelayExpr<TContext, TExpressionEvent, TParams, TEvent>;\n}\n\nexport interface RaiseActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TDelay\n  > {\n  event: TEvent | SendExpr<TContext, TExpressionEvent, TParams, TEvent, TEvent>;\n}\n\nexport interface SendToActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TDelay\n  > {\n  event:\n    | TSentEvent\n    | SendExpr<TContext, TExpressionEvent, TParams, TSentEvent, TEvent>;\n}\n\nexport type Assigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = (\n  args: AssignArgs<TContext, TExpressionEvent, TEvent, TActor>,\n  params: TParams\n) => Partial<TContext>;\n\nexport type PartialAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TKey extends keyof TContext\n> = (\n  args: AssignArgs<TContext, TExpressionEvent, TEvent, TActor>,\n  params: TParams\n) => TContext[TKey];\n\nexport type PropertyAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = {\n  [K in keyof TContext]?:\n    | PartialAssigner<TContext, TExpressionEvent, TParams, TEvent, TActor, K>\n    | TContext[K];\n};\n\nexport type Mapper<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TResult,\n  TEvent extends EventObject\n> = (args: {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      Record<string, AnyActorRef>, // TODO: this should be replaced with `TChildren`\n      StateValue,\n      string,\n      unknown,\n      TODO, // TMeta\n      TODO // State schema\n    >,\n    TEvent,\n    AnyEventObject\n  >;\n}) => TResult;\n\nexport interface TransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends Omit<\n    TransitionConfig<\n      TContext,\n      TEvent,\n      TEvent,\n      TODO,\n      TODO,\n      TODO,\n      TODO,\n      TODO, // TEmitted\n      TODO // TMeta\n    >,\n    | 'target'\n    // `guard` is correctly rejected by `extends` here and `actions` should be too\n    // however, `any` passed to `TransitionConfig` as `TAction` collapses its `.actions` to `any` and it's accidentally allowed here\n    // it doesn't exactly have to be incorrect, we are overriding this here anyway but it looks like a lucky accident rather than smth done on purpose\n    | 'guard'\n  > {\n  target: ReadonlyArray<StateNode<TContext, TEvent>> | undefined;\n  source: StateNode<TContext, TEvent>;\n  actions: readonly UnknownAction[];\n  reenter: boolean;\n  guard?: UnknownGuard;\n  eventType: EventDescriptor<TEvent>;\n  toJSON: () => {\n    target: string[] | undefined;\n    source: string;\n    actions: readonly UnknownAction[];\n    guard?: UnknownGuard;\n    eventType: EventDescriptor<TEvent>;\n    meta?: Record<string, any>;\n  };\n}\n\nexport type AnyTransitionDefinition = TransitionDefinition<any, any>;\n\nexport interface InitialTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  target: ReadonlyArray<StateNode<TContext, TEvent>>;\n  guard?: never;\n}\n\nexport type TransitionDefinitionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in EventDescriptor<TEvent>]: Array<\n    TransitionDefinition<TContext, ExtractEvent<TEvent, K>>\n  >;\n};\n\nexport interface DelayedTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  delay: number | string | DelayExpr<TContext, TEvent, undefined, TEvent>;\n}\n\nexport interface StateLike<TContext extends MachineContext> {\n  value: StateValue;\n  context: TContext;\n  event: EventObject;\n}\n\nexport interface StateConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  context: TContext;\n  historyValue?: HistoryValue<TContext, TEvent>;\n  /** @internal */\n  _nodes: Array<StateNode<TContext, TEvent>>;\n  children: Record<string, AnyActorRef>;\n  status: SnapshotStatus;\n  output?: any;\n  error?: unknown;\n  machine?: StateMachine<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >;\n}\n\nexport interface ActorOptions<TLogic extends AnyActorLogic> {\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   *\n   * @remarks\n   * You can create your own “clock”. The clock interface is an object with two\n   * functions/methods:\n   *\n   * - `setTimeout` - same arguments as `window.setTimeout(fn, timeout)`\n   * - `clearTimeout` - same arguments as `window.clearTimeout(id)`\n   *\n   * By default, the native `setTimeout` and `clearTimeout` functions are used.\n   *\n   * For testing, XState provides `SimulatedClock`.\n   * @see {@link Clock}\n   * @see {@link SimulatedClock}\n   */\n  clock?: Clock;\n  /**\n   * Specifies the logger to be used for `log(...)` actions. Defaults to the\n   * native `console.log(...)` method.\n   */\n  logger?: (...args: any[]) => void;\n  parent?: AnyActorRef;\n  /** @internal */\n  syncSnapshot?: boolean;\n  /** The custom `id` for referencing this service. */\n  id?: string;\n  /** @deprecated Use `inspect` instead. */\n  devTools?: never;\n\n  /** The system ID to register this actor under. */\n  systemId?: string;\n  /** The input data to pass to the actor. */\n  input?: InputFrom<TLogic>;\n\n  /**\n   * Initializes actor logic from a specific persisted internal state.\n   *\n   * @remarks\n   * If the state is compatible with the actor logic, when the actor is started\n   * it will be at that persisted state. Actions from machine actors will not be\n   * re-executed, because they are assumed to have been already executed.\n   * However, invocations will be restarted, and spawned actors will be restored\n   * recursively.\n   *\n   * Can be generated with {@link Actor.getPersistedSnapshot}.\n   * @see https://stately.ai/docs/persistence\n   */\n  snapshot?: Snapshot<unknown>;\n\n  /** @deprecated Use `snapshot` instead. */\n  state?: Snapshot<unknown>;\n\n  /** The source actor logic. */\n  src?: string | AnyActorLogic;\n\n  /**\n   * A callback function or observer object which can be used to inspect actor\n   * system updates.\n   *\n   * @remarks\n   * If a callback function is provided, it can accept an inspection event\n   * argument. The types of inspection events that can be observed include:\n   *\n   * - `@xstate.actor` - An actor ref has been created in the system\n   * - `@xstate.event` - An event was sent from a source actor ref to a target\n   *   actor ref in the system\n   * - `@xstate.snapshot` - An actor ref emitted a snapshot due to a received\n   *   event\n   *\n   * @example\n   *\n   * ```ts\n   * import { createMachine } from 'xstate';\n   *\n   * const machine = createMachine({\n   *   // ...\n   * });\n   *\n   * const actor = createActor(machine, {\n   *   inspect: (inspectionEvent) => {\n   *     if (inspectionEvent.actorRef === actor) {\n   *       // This event is for the root actor\n   *     }\n   *\n   *     if (inspectionEvent.type === '@xstate.actor') {\n   *       console.log(inspectionEvent.actorRef);\n   *     }\n   *\n   *     if (inspectionEvent.type === '@xstate.event') {\n   *       console.log(inspectionEvent.sourceRef);\n   *       console.log(inspectionEvent.actorRef);\n   *       console.log(inspectionEvent.event);\n   *     }\n   *\n   *     if (inspectionEvent.type === '@xstate.snapshot') {\n   *       console.log(inspectionEvent.actorRef);\n   *       console.log(inspectionEvent.event);\n   *       console.log(inspectionEvent.snapshot);\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * Alternately, an observer object (`{ next?, error?, complete? }`) can be\n   * provided:\n   *\n   * @example\n   *\n   * ```ts\n   * const actor = createActor(machine, {\n   *   inspect: {\n   *     next: (inspectionEvent) => {\n   *       if (inspectionEvent.actorRef === actor) {\n   *         // This event is for the root actor\n   *       }\n   *\n   *       if (inspectionEvent.type === '@xstate.actor') {\n   *         console.log(inspectionEvent.actorRef);\n   *       }\n   *\n   *       if (inspectionEvent.type === '@xstate.event') {\n   *         console.log(inspectionEvent.sourceRef);\n   *         console.log(inspectionEvent.actorRef);\n   *         console.log(inspectionEvent.event);\n   *       }\n   *\n   *       if (inspectionEvent.type === '@xstate.snapshot') {\n   *         console.log(inspectionEvent.actorRef);\n   *         console.log(inspectionEvent.event);\n   *         console.log(inspectionEvent.snapshot);\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  inspect?:\n    | Observer<InspectionEvent>\n    | ((inspectionEvent: InspectionEvent) => void);\n}\n\nexport type AnyActor = Actor<any>;\n\n/** @deprecated Use `AnyActor` instead. */\nexport type AnyInterpreter = AnyActor;\n\n// Based on RxJS types\nexport type Observer<T> = {\n  next?: (value: T) => void;\n  error?: (err: unknown) => void;\n  complete?: () => void;\n};\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface InteropObservable<T> {\n  [Symbol.observable]: () => InteropSubscribable<T>;\n}\n\nexport interface InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n}\n\nexport interface Subscribable<T> extends InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n  subscribe(\n    next: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription;\n}\n\ntype EventDescriptorMatches<\n  TEventType extends string,\n  TNormalizedDescriptor\n> = TEventType extends TNormalizedDescriptor ? true : false;\n\nexport type ExtractEvent<\n  TEvent extends EventObject,\n  TDescriptor extends EventDescriptor<TEvent>\n> = string extends TEvent['type']\n  ? TEvent\n  : NormalizeDescriptor<TDescriptor> extends infer TNormalizedDescriptor\n    ? TEvent extends any\n      ? // true is the check type here to match both true and boolean\n        true extends EventDescriptorMatches<\n          TEvent['type'],\n          TNormalizedDescriptor\n        >\n        ? TEvent\n        : never\n      : never\n    : never;\n\nexport interface BaseActorRef<TEvent extends EventObject> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorLike<TCurrent, TEvent extends EventObject>\n  extends Subscribable<TCurrent> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorRef<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TEmitted extends EventObject = EventObject\n> extends Subscribable<TSnapshot>,\n    InteropObservable<TSnapshot> {\n  /** The unique identifier for this actor relative to its parent. */\n  id: string;\n  sessionId: string;\n  /** @internal */\n  _send: (event: TEvent) => void;\n  send: (event: TEvent) => void;\n  start: () => void;\n  getSnapshot: () => TSnapshot;\n  getPersistedSnapshot: () => Snapshot<unknown>;\n  stop: () => void;\n  toJSON?: () => any;\n  // TODO: figure out how to hide this externally as `sendTo(ctx => ctx.actorRef._parent._parent._parent._parent)` shouldn't be allowed\n  _parent?: AnyActorRef;\n  system: AnyActorSystem;\n  /** @internal */\n  _processingStatus: ProcessingStatus;\n  src: string | AnyActorLogic;\n  // TODO: remove from ActorRef interface\n  // (should only be available on Actor)\n  on: <TType extends TEmitted['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: TEmitted & (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ) => Subscription;\n}\n\nexport type AnyActorRef = ActorRef<\n  any,\n  any, // TODO: shouldn't this be AnyEventObject?\n  any\n>;\n\nexport type ActorRefLike = Pick<\n  AnyActorRef,\n  'sessionId' | 'send' | 'getSnapshot'\n>;\n\nexport type UnknownActorRef = ActorRef<Snapshot<unknown>, EventObject>;\n\nexport type ActorLogicFrom<T> =\n  ReturnTypeOrValue<T> extends infer R\n    ? R extends StateMachine<\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any, // TMeta\n        any // TStateSchema\n      >\n      ? R\n      : R extends Promise<infer U>\n        ? PromiseActorLogic<U>\n        : never\n    : never;\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\nexport type ActorRefFrom<T> =\n  ReturnTypeOrValue<T> extends infer R\n    ? R extends StateMachine<\n        infer TContext,\n        infer TEvent,\n        infer TChildren,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer TStateValue,\n        infer TTag,\n        infer _TInput,\n        infer TOutput,\n        infer TEmitted,\n        infer TMeta,\n        infer TStateSchema\n      >\n      ? ActorRef<\n          MachineSnapshot<\n            TContext,\n            TEvent,\n            TChildren,\n            TStateValue,\n            TTag,\n            TOutput,\n            TMeta,\n            TStateSchema\n          >,\n          TEvent,\n          TEmitted\n        >\n      : R extends Promise<infer U>\n        ? ActorRefFrom<PromiseActorLogic<U>>\n        : R extends ActorLogic<\n              infer TSnapshot,\n              infer TEvent,\n              infer _TInput,\n              infer _TSystem,\n              infer TEmitted\n            >\n          ? ActorRef<TSnapshot, TEvent, TEmitted>\n          : never\n    : never;\n\nexport type ActorRefFromLogic<T extends AnyActorLogic> = ActorRef<\n  SnapshotFrom<T>,\n  EventFromLogic<T>,\n  EmittedFrom<T>\n>;\n\nexport type DevToolsAdapter = (service: AnyActor) => void;\n\n/** @deprecated Use `Actor<T>` instead. */\nexport type InterpreterFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> =\n  ReturnTypeOrValue<T> extends StateMachine<\n    infer TContext,\n    infer TEvent,\n    infer TChildren,\n    infer _TActor,\n    infer _TAction,\n    infer _TGuard,\n    infer _TDelay,\n    infer TStateValue,\n    infer TTag,\n    infer TInput,\n    infer TOutput,\n    infer TEmitted,\n    infer TMeta,\n    infer TStateSchema\n  >\n    ? Actor<\n        ActorLogic<\n          MachineSnapshot<\n            TContext,\n            TEvent,\n            TChildren,\n            TStateValue,\n            TTag,\n            TOutput,\n            TMeta,\n            TStateSchema\n          >,\n          TEvent,\n          TInput,\n          AnyActorSystem,\n          TEmitted\n        >\n      >\n    : never;\n\nexport type MachineImplementationsFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> =\n  ReturnTypeOrValue<T> extends StateMachine<\n    infer TContext,\n    infer TEvent,\n    infer _TChildren,\n    infer TActor,\n    infer TAction,\n    infer TGuard,\n    infer TDelay,\n    infer _TStateValue,\n    infer TTag,\n    infer _TInput,\n    infer _TOutput,\n    infer TEmitted,\n    infer _TMeta,\n    infer _TStateSchema\n  >\n    ? InternalMachineImplementations<\n        ResolvedStateMachineTypes<\n          TContext,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay,\n          TTag,\n          TEmitted\n        >\n      >\n    : never;\n\nexport interface ActorScope<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem = AnyActorSystem,\n  TEmitted extends EventObject = EventObject\n> {\n  self: ActorRef<TSnapshot, TEvent, TEmitted>;\n  id: string;\n  sessionId: string;\n  logger: (...args: any[]) => void;\n  defer: (fn: () => void) => void;\n  emit: (event: TEmitted) => void;\n  system: TSystem;\n  stopChild: (child: AnyActorRef) => void;\n  actionExecutor: ActionExecutor;\n}\n\nexport type AnyActorScope = ActorScope<\n  any, // TSnapshot\n  any, // TEvent\n  AnyActorSystem,\n  any // TEmitted\n>;\n\nexport type SnapshotStatus = 'active' | 'done' | 'error' | 'stopped';\n\nexport type Snapshot<TOutput> =\n  | {\n      status: 'active';\n      output: undefined;\n      error: undefined;\n    }\n  | {\n      status: 'done';\n      output: TOutput;\n      error: undefined;\n    }\n  | {\n      status: 'error';\n      output: undefined;\n      error: unknown;\n    }\n  | {\n      status: 'stopped';\n      output: undefined;\n      error: undefined;\n    };\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\nexport interface ActorLogic<\n  in out TSnapshot extends Snapshot<unknown>, // it's invariant because it's also part of `ActorScope[\"self\"][\"getSnapshot\"]`\n  in out TEvent extends EventObject, // it's invariant because it's also part of `ActorScope[\"self\"][\"send\"]`\n  in TInput = NonReducibleUnknown,\n  TSystem extends AnyActorSystem = AnyActorSystem,\n  in out TEmitted extends EventObject = EventObject // it's invariant because it's also aprt of `ActorScope[\"self\"][\"on\"]`\n> {\n  /** The initial setup/configuration used to create the actor logic. */\n  config?: unknown;\n  /**\n   * Transition function that processes the current state and an incoming event\n   * to produce a new state.\n   *\n   * @param snapshot - The current state.\n   * @param event - The incoming event.\n   * @param actorScope - The actor scope.\n   * @returns The new state.\n   */\n  transition: (\n    snapshot: TSnapshot,\n    event: TEvent,\n    actorScope: ActorScope<TSnapshot, TEvent, TSystem, TEmitted>\n  ) => TSnapshot;\n  /**\n   * Called to provide the initial state of the actor.\n   *\n   * @param actorScope - The actor scope.\n   * @param input - The input for the initial state.\n   * @returns The initial state.\n   */\n  getInitialSnapshot: (\n    actorScope: ActorScope<TSnapshot, TEvent, TSystem, TEmitted>,\n    input: TInput\n  ) => TSnapshot;\n  /**\n   * Called when Actor is created to restore the internal state of the actor\n   * given a persisted state. The persisted state can be created by\n   * `getPersistedSnapshot`.\n   *\n   * @param persistedState - The persisted state to restore from.\n   * @param actorScope - The actor scope.\n   * @returns The restored state.\n   */\n  restoreSnapshot?: (\n    persistedState: Snapshot<unknown>,\n    actorScope: ActorScope<TSnapshot, TEvent, AnyActorSystem, TEmitted>\n  ) => TSnapshot;\n  /**\n   * Called when the actor is started.\n   *\n   * @param snapshot - The starting state.\n   * @param actorScope - The actor scope.\n   */\n  start?: (\n    snapshot: TSnapshot,\n    actorScope: ActorScope<TSnapshot, TEvent, AnyActorSystem, TEmitted>\n  ) => void;\n  /**\n   * Obtains the internal state of the actor in a representation which can be be\n   * persisted. The persisted state can be restored by `restoreSnapshot`.\n   *\n   * @param snapshot - The current state.\n   * @returns The a representation of the internal state to be persisted.\n   */\n  getPersistedSnapshot: (\n    snapshot: TSnapshot,\n    options?: unknown\n  ) => Snapshot<unknown>;\n}\n\nexport type AnyActorLogic = ActorLogic<\n  any, // snapshot\n  any, // event\n  any, // input\n  any, // system\n  any // emitted\n>;\n\nexport type UnknownActorLogic = ActorLogic<\n  any, // snapshot\n  any, // event\n  any, // input\n  AnyActorSystem,\n  any // emitted\n>;\n\nexport type SnapshotFrom<T> =\n  ReturnTypeOrValue<T> extends infer R\n    ? R extends ActorRef<infer TSnapshot, infer _, infer __>\n      ? TSnapshot\n      : R extends Actor<infer TLogic>\n        ? SnapshotFrom<TLogic>\n        : R extends ActorLogic<\n              infer _TSnapshot,\n              infer _TEvent,\n              infer _TInput,\n              infer _TEmitted,\n              infer _TSystem\n            >\n          ? ReturnType<R['transition']>\n          : R extends ActorScope<\n                infer TSnapshot,\n                infer _TEvent,\n                infer _TEmitted,\n                infer _TSystem\n              >\n            ? TSnapshot\n            : never\n    : never;\n\nexport type EventFromLogic<TLogic extends AnyActorLogic> =\n  TLogic extends ActorLogic<\n    infer _TSnapshot,\n    infer TEvent,\n    infer _TInput,\n    infer _TEmitted,\n    infer _TSystem\n  >\n    ? TEvent\n    : never;\n\nexport type EmittedFrom<TLogic extends AnyActorLogic> =\n  TLogic extends ActorLogic<\n    infer _TSnapshot,\n    infer _TEvent,\n    infer _TInput,\n    infer _TSystem,\n    infer TEmitted\n  >\n    ? TEmitted\n    : never;\n\ntype ResolveEventType<T> =\n  ReturnTypeOrValue<T> extends infer R\n    ? R extends StateMachine<\n        infer _TContext,\n        infer TEvent,\n        infer _TChildren,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TStateValue,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TEmitted,\n        infer _TMeta,\n        infer _TStateSchema\n      >\n      ? TEvent\n      : R extends MachineSnapshot<\n            infer _TContext,\n            infer TEvent,\n            infer _TChildren,\n            infer _TStateValue,\n            infer _TTag,\n            infer _TOutput,\n            infer _TMeta,\n            infer _TStateSchema\n          >\n        ? TEvent\n        : R extends ActorRef<infer _TSnapshot, infer TEvent, infer _TEmitted>\n          ? TEvent\n          : never\n    : never;\n\nexport type EventFrom<\n  T,\n  K extends Prop<TEvent, 'type'> = never,\n  TEvent extends EventObject = ResolveEventType<T>\n> = IsNever<K> extends true ? TEvent : ExtractEvent<TEvent, K>;\n\nexport type ContextFrom<T> =\n  ReturnTypeOrValue<T> extends infer R\n    ? R extends StateMachine<\n        infer TContext,\n        infer _TEvent,\n        infer _TChildren,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TStateValue,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TEmitted,\n        infer _TMeta,\n        infer _TStateSchema\n      >\n      ? TContext\n      : R extends MachineSnapshot<\n            infer TContext,\n            infer _TEvent,\n            infer _TChildren,\n            infer _TStateValue,\n            infer _TTag,\n            infer _TOutput,\n            infer _TMeta,\n            infer _TStateSchema\n          >\n        ? TContext\n        : R extends Actor<infer TActorLogic>\n          ? TActorLogic extends StateMachine<\n              infer TContext,\n              infer _TEvent,\n              infer _TChildren,\n              infer _TActor,\n              infer _TAction,\n              infer _TGuard,\n              infer _TDelay,\n              infer _TStateValue,\n              infer _TTag,\n              infer _TInput,\n              infer _TOutput,\n              infer _TEmitted,\n              infer _TMeta,\n              infer _TStateSchema\n            >\n            ? TContext\n            : never\n          : never\n    : never;\n\nexport type InferEvent<E extends EventObject> = {\n  [T in E['type']]: { type: T } & Extract<E, { type: T }>;\n}[E['type']];\n\nexport type TODO = any;\n\nexport type StateValueFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['matches']\n>[0];\n\nexport type TagsFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['hasTag']\n>[0];\n\nexport interface ActorSystemInfo {\n  actors: Record<string, AnyActorRef>;\n}\n\nexport type RequiredActorOptions<TActor extends ProvidedActor> =\n  | (undefined extends TActor['id'] ? never : 'id')\n  | (undefined extends InputFrom<TActor['logic']> ? never : 'input');\n\nexport type RequiredLogicInput<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\ntype ExtractLiteralString<T extends string | undefined> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\ntype ToConcreteChildren<TActor extends ProvidedActor> = {\n  [A in TActor as ExtractLiteralString<A['id']>]?: ActorRefFromLogic<\n    A['logic']\n  >;\n};\n\nexport type ToChildren<TActor extends ProvidedActor> =\n  // only proceed further if all configured `src`s are literal strings\n  string extends TActor['src']\n    ? // TODO: replace `AnyActorRef` with `UnknownActorRef`~\n      // or maybe even `TActor[\"logic\"]` since it's possible to configure `{ src: string; logic: SomeConcreteLogic }`\n      // TODO: consider adding `| undefined` here\n      Record<string, AnyActorRef>\n    : Compute<\n        ToConcreteChildren<TActor> &\n          {\n            include: {\n              [id: string]: TActor extends any\n                ? ActorRefFromLogic<TActor['logic']> | undefined\n                : never;\n            };\n            exclude: unknown;\n          }[undefined extends TActor['id'] // if not all actors have literal string IDs then we need to create an index signature containing all possible actor types\n            ? 'include'\n            : string extends TActor['id']\n              ? 'include'\n              : 'exclude']\n      >;\n\nexport type StateSchema = {\n  id?: string;\n  states?: Record<string, StateSchema>;\n\n  // Other types\n  // Needed because TS treats objects with all optional properties as a \"weak\" object\n  // https://github.com/statelyai/xstate/issues/5031\n  type?: unknown;\n  invoke?: unknown;\n  on?: unknown;\n  entry?: unknown;\n  exit?: unknown;\n  onDone?: unknown;\n  after?: unknown;\n  always?: unknown;\n  meta?: unknown;\n  output?: unknown;\n  tags?: unknown;\n  description?: unknown;\n};\n\nexport type StateId<\n  TSchema extends StateSchema,\n  TKey extends string = '(machine)',\n  TParentKey extends string | null = null\n> =\n  | (TSchema extends { id: string }\n      ? TSchema['id']\n      : TParentKey extends null\n        ? TKey\n        : `${TParentKey}.${TKey}`)\n  | (TSchema['states'] extends Record<string, any>\n      ? Values<{\n          [K in keyof TSchema['states'] & string]: StateId<\n            TSchema['states'][K],\n            K,\n            TParentKey extends string\n              ? `${TParentKey}.${TKey}`\n              : TSchema['id'] extends string\n                ? TSchema['id']\n                : TKey\n          >;\n        }>\n      : never);\n\nexport interface StateMachineTypes {\n  context: MachineContext;\n  events: EventObject;\n  actors: ProvidedActor;\n  actions: ParameterizedObject;\n  guards: ParameterizedObject;\n  delays: string;\n  tags: string;\n  emitted: EventObject;\n}\n\n/** @deprecated */\nexport interface ResolvedStateMachineTypes<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TEmitted extends EventObject = EventObject\n> {\n  context: TContext;\n  events: TEvent;\n  actors: TActor;\n  actions: TAction;\n  guards: TGuard;\n  delays: TDelay;\n  tags: TTag;\n  emitted: TEmitted;\n}\n\nexport type GetConcreteByKey<\n  T,\n  TKey extends keyof T,\n  TValue extends T[TKey]\n> = T & Record<TKey, TValue>;\n\ntype _GroupStateKeys<\n  T extends StateSchema,\n  S extends keyof T['states']\n> = S extends any\n  ? T['states'][S] extends { type: 'history' }\n    ? [never, never]\n    : T extends { type: 'parallel' }\n      ? [S, never]\n      : 'states' extends keyof T['states'][S]\n        ? [S, never]\n        : [never, S]\n  : never;\n\ntype GroupStateKeys<T extends StateSchema, S extends keyof T['states']> = {\n  nonLeaf: _GroupStateKeys<T, S & string>[0];\n  leaf: _GroupStateKeys<T, S & string>[1];\n};\n\nexport type ToStateValue<T extends StateSchema> = T extends {\n  states: Record<infer S, any>;\n}\n  ? IsNever<S> extends true\n    ? {}\n    :\n        | GroupStateKeys<T, S>['leaf']\n        | (IsNever<GroupStateKeys<T, S>['nonLeaf']> extends false\n            ? T extends { type: 'parallel' }\n              ? {\n                  [K in GroupStateKeys<T, S>['nonLeaf']]: ToStateValue<\n                    T['states'][K]\n                  >;\n                }\n              : Compute<\n                  Values<{\n                    [K in GroupStateKeys<T, S>['nonLeaf']]: {\n                      [StateKey in K]: ToStateValue<T['states'][K]>;\n                    };\n                  }>\n                >\n            : never)\n  : {};\n\nexport interface ExecutableActionObject {\n  type: string;\n  info: ActionArgs<MachineContext, EventObject, EventObject>;\n  params: NonReducibleUnknown;\n  exec:\n    | ((info: ActionArgs<any, any, any>, params: unknown) => void)\n    | undefined;\n}\n\nexport interface ToExecutableAction<T extends ParameterizedObject>\n  extends ExecutableActionObject {\n  type: T['type'];\n  params: T['params'];\n  exec: undefined;\n}\n\nexport interface ExecutableSpawnAction extends ExecutableActionObject {\n  type: 'xstate.spawnChild';\n  info: ActionArgs<MachineContext, EventObject, EventObject>;\n  params: {\n    id: string;\n    actorRef: AnyActorRef | undefined;\n    src: string | AnyActorLogic;\n  };\n}\n\n// TODO: cover all that can be actually returned\nexport type SpecialExecutableAction =\n  | ExecutableSpawnAction\n  | ExecutableRaiseAction\n  | ExecutableSendToAction;\n\nexport type ExecutableActionsFrom<T extends AnyActorLogic> =\n  T extends StateMachine<\n    infer _TContext,\n    infer _TEvent,\n    infer _TChildren,\n    infer _TActor,\n    infer TAction,\n    infer _TGuard,\n    infer _TDelay,\n    infer _TStateValue,\n    infer _TTag,\n    infer _TInput,\n    infer _TOutput,\n    infer _TEmitted,\n    infer _TMeta,\n    infer _TStateSchema\n  >\n    ?\n        | SpecialExecutableAction\n        | (string extends TAction['type'] ? never : ToExecutableAction<TAction>)\n    : never;\n\nexport type ActionExecutor = (actionToExecute: ExecutableActionObject) => void;\n\nexport type BuiltinActionResolution = [\n  AnyMachineSnapshot,\n  NonReducibleUnknown, // params\n  UnknownAction[] | undefined\n];\n","import isDevelopment from '#is-development';\nimport { XSTATE_ERROR } from '../constants.ts';\nimport { createErrorActorEvent } from '../eventUtils.ts';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  Cast,\n  DelayExpr,\n  DoNotInfer,\n  EventFrom,\n  EventObject,\n  ExecutableActionObject,\n  InferEvent,\n  MachineContext,\n  ParameterizedObject,\n  SendExpr,\n  SendToActionOptions,\n  BuiltinActionResolution,\n  SpecialTargets,\n  UnifiedArg\n} from '../types.ts';\n\nfunction resolveSendTo(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    to,\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    to:\n      | AnyActorRef\n      | string\n      | ((\n          args: UnifiedArg<MachineContext, EventObject, EventObject>,\n          params: ParameterizedObject['params'] | undefined\n        ) => AnyActorRef | string);\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject\n        >\n      | undefined;\n  },\n  extra: { deferredActorIds: string[] | undefined }\n): BuiltinActionResolution {\n  const delaysMap = snapshot.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function'\n        ? configDelay(args, actionParams)\n        : configDelay;\n  } else {\n    resolvedDelay =\n      typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef: AnyActorRef | string | undefined;\n\n  if (typeof resolvedTarget === 'string') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget)\n        ? resolvedTarget\n        : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(\n        `Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`\n      );\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n\n  return [\n    snapshot,\n    {\n      to: targetActorRef,\n      targetId: typeof resolvedTarget === 'string' ? resolvedTarget : undefined,\n      event: resolvedEvent,\n      id,\n      delay: resolvedDelay\n    },\n    undefined\n  ];\n}\n\nfunction retryResolveSendTo(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  params: {\n    to: AnyActorRef;\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\n\nfunction executeSendTo(\n  actorScope: AnyActorScope,\n  params: {\n    to: AnyActorRef;\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const { to, event, delay, id } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(\n        actorScope.self,\n        to,\n        event,\n        delay,\n        id\n      );\n      return;\n    }\n    actorScope.system._relay(\n      actorScope.self,\n      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n      // if it initially started as a string\n      to,\n      event.type === XSTATE_ERROR\n        ? createErrorActorEvent(actorScope.self.id, (event as any).data)\n        : event\n    );\n  });\n}\n\nexport interface SendToAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nexport function sendTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TTargetActor extends AnyActorRef,\n  TEvent extends EventObject,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  to: SendToActionTarget<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TTargetActor,\n    TEvent\n  >,\n  eventOrExpr:\n    | EventFrom<TTargetActor>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TParams,\n        InferEvent<Cast<EventFrom<TTargetActor>, EventObject>>,\n        TEvent\n      >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    DoNotInfer<TEvent>,\n    TUsedDelay\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  TDelay,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function sendTo(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  sendTo.type = 'xstate.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nexport function sendParent<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TSentEvent extends EventObject = AnyEventObject,\n  TEvent extends EventObject = AnyEventObject,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  event:\n    | TSentEvent\n    | SendExpr<TContext, TExpressionEvent, TParams, TSentEvent, TEvent>,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TUsedDelay\n  >\n) {\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    AnyActorRef,\n    TEvent,\n    TDelay,\n    TUsedDelay\n  >(SpecialTargets.Parent, event, options as any);\n}\n\ntype SendToActionTarget<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TTargetActor extends AnyActorRef,\n  TEvent extends EventObject\n> =\n  | string\n  | TTargetActor\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => string | TTargetActor);\n\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nexport function forwardTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  target: SendToActionTarget<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    AnyActorRef,\n    TEvent\n  >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TUsedDelay\n  >\n) {\n  if (isDevelopment && (!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget =\n        typeof originalTarget === 'function'\n          ? originalTarget(...args)\n          : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(\n          `Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`\n        );\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    AnyActorRef,\n    TEvent,\n    TDelay,\n    TUsedDelay\n  >(target, ({ event }: any) => event, options);\n}\n\nexport interface ExecutableSendToAction extends ExecutableActionObject {\n  type: 'xstate.sendTo';\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n    to: AnyActorRef;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { Guard, evaluateGuard } from '../guards.ts';\nimport {\n  Action,\n  ActionArgs,\n  ActionFunction,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  ProvidedActor,\n  BuiltinActionResolution,\n  UnifiedArg\n} from '../types.ts';\nimport { assign } from './assign.ts';\nimport { cancel } from './cancel.ts';\nimport { emit } from './emit.ts';\nimport { raise } from './raise.ts';\nimport { sendParent, sendTo } from './send.ts';\nimport { spawnChild } from './spawnChild.ts';\nimport { stopChild } from './stopChild.ts';\n\ninterface ActionEnqueuer<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> {\n  (\n    action: Action<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      undefined,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TEmitted\n    >\n  ): void;\n  assign: (\n    ...args: Parameters<\n      typeof assign<TContext, TExpressionEvent, undefined, TEvent, TActor>\n    >\n  ) => void;\n  cancel: (\n    ...args: Parameters<\n      typeof cancel<TContext, TExpressionEvent, undefined, TEvent>\n    >\n  ) => void;\n  raise: (\n    ...args: Parameters<\n      typeof raise<\n        TContext,\n        TExpressionEvent,\n        TEvent,\n        undefined,\n        TDelay,\n        TDelay\n      >\n    >\n  ) => void;\n  sendTo: <TTargetActor extends AnyActorRef>(\n    ...args: Parameters<\n      typeof sendTo<\n        TContext,\n        TExpressionEvent,\n        undefined,\n        TTargetActor,\n        TEvent,\n        TDelay,\n        TDelay\n      >\n    >\n  ) => void;\n  sendParent: (\n    ...args: Parameters<\n      typeof sendParent<\n        TContext,\n        TExpressionEvent,\n        undefined,\n        AnyEventObject,\n        TEvent,\n        TDelay,\n        TDelay\n      >\n    >\n  ) => void;\n  spawnChild: (\n    ...args: Parameters<\n      typeof spawnChild<TContext, TExpressionEvent, undefined, TEvent, TActor>\n    >\n  ) => void;\n  stopChild: (\n    ...args: Parameters<\n      typeof stopChild<TContext, TExpressionEvent, undefined, TEvent>\n    >\n  ) => void;\n  emit: (\n    ...args: Parameters<\n      typeof emit<TContext, TExpressionEvent, undefined, TEvent, TEmitted>\n    >\n  ) => void;\n}\n\nfunction resolveEnqueueActions(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    collect\n  }: {\n    collect: CollectActions<\n      MachineContext,\n      EventObject,\n      ParameterizedObject['params'] | undefined,\n      EventObject,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string,\n      EventObject\n    >;\n  }\n): BuiltinActionResolution {\n  const actions: any[] = [];\n  const enqueue: Parameters<typeof collect>[0]['enqueue'] = function enqueue(\n    action\n  ) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push(assign(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push(cancel(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push((raise as typeof enqueue.raise)(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push((sendTo as typeof enqueue.sendTo)(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push((sendParent as typeof enqueue.sendParent)(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push(spawnChild(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push(stopChild(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n\n  collect(\n    {\n      context: args.context,\n      event: args.event,\n      enqueue,\n      check: (guard) =>\n        evaluateGuard(guard, snapshot.context, args.event, snapshot),\n      self: actorScope.self,\n      system: actorScope.system\n    },\n    actionParams\n  );\n\n  return [snapshot, undefined, actions];\n}\n\nexport interface EnqueueActionsAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent;\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n}\n\ninterface CollectActionsArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> extends UnifiedArg<TContext, TExpressionEvent, TEvent> {\n  check: (\n    guard: Guard<TContext, TExpressionEvent, undefined, TGuard>\n  ) => boolean;\n  enqueue: ActionEnqueuer<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >;\n}\n\ntype CollectActions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TEmitted extends EventObject\n> = (\n  {\n    context,\n    event,\n    check,\n    enqueue,\n    self\n  }: CollectActionsArg<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >,\n  params: TParams\n) => void;\n\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nexport function enqueueActions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject = TExpressionEvent,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = never,\n  TEmitted extends EventObject = EventObject\n>(\n  collect: CollectActions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TEmitted\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay,\n  TEmitted\n> {\n  function enqueueActions(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: unknown\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n\n  return enqueueActions;\n}\n","import isDevelopment from '#is-development';\nimport {\n  ActionArgs,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  LogExpr,\n  MachineContext,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableLogValue<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> = string | LogExpr<TContext, TExpressionEvent, TParams, TEvent>;\n\nfunction resolveLog(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    value,\n    label\n  }: {\n    value: ResolvableLogValue<any, any, any, any>;\n    label: string | undefined;\n  }\n): BuiltinActionResolution {\n  return [\n    snapshot,\n    {\n      value:\n        typeof value === 'function' ? value(actionArgs, actionParams) : value,\n      label\n    },\n    undefined\n  ];\n}\n\nfunction executeLog(\n  { logger }: AnyActorScope,\n  { value, label }: { value: unknown; label: string | undefined }\n) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n\nexport interface LogAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nexport function log<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  value: ResolvableLogValue<TContext, TExpressionEvent, TParams, TEvent> = ({\n    context,\n    event\n  }) => ({ context, event }),\n  label?: string\n): LogAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function log(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n\n  return log;\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope as any)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  AnyEventObject,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types';\n\ninterface CallbackInstanceState<TEvent extends EventObject> {\n  receivers: Set<(e: TEvent) => void> | undefined;\n  dispose: (() => void) | void;\n}\n\nconst instanceStates = /* #__PURE__ */ new WeakMap<\n  AnyActorRef,\n  CallbackInstanceState<any>\n>();\n\nexport type CallbackSnapshot<TInput> = Snapshot<undefined> & {\n  input: TInput;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  CallbackSnapshot<TInput>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n> = ActorRefFromLogic<CallbackActorLogic<TEvent, TInput>>;\n\ntype Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type CallbackLogicFunction<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive,\n  emit\n}: {\n  /**\n   * Data that was provided to the callback actor\n   *\n   * @see {@link https://stately.ai/docs/input | Input docs}\n   */\n  input: TInput;\n  /** The actor system to which the callback actor belongs */\n  system: AnyActorSystem;\n  /** The parent actor of the callback actor */\n  self: CallbackActorRef<TEvent>;\n  /** A function that can send events back to the parent actor */\n  sendBack: (event: TSentEvent) => void;\n  /**\n   * A function that can be called with a listener function argument; the\n   * listener is then called whenever events are received by the callback actor\n   */\n  receive: Receiver<TEvent>;\n  emit: (emitted: TEmitted) => void;\n}) => (() => void) | void;\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromCallback<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  callback: CallbackLogicFunction<TEvent, AnyEventObject, TInput, TEmitted>\n): CallbackActorLogic<TEvent, TInput, TEmitted> {\n  const logic: CallbackActorLogic<TEvent, TInput, TEmitted> = {\n    config: callback,\n    start: (state, actorScope) => {\n      const { self, system, emit } = actorScope;\n\n      const callbackState: CallbackInstanceState<TEvent> = {\n        receivers: undefined,\n        dispose: undefined\n      };\n\n      instanceStates.set(self, callbackState);\n\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: (event) => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: (listener) => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState: CallbackInstanceState<TEvent> = instanceStates.get(\n        actorScope.self\n      )!;\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        callbackState.dispose?.();\n        return state;\n      }\n\n      callbackState.receivers?.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot,\n  Subscribable,\n  Subscription\n} from '../types';\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\nexport type ObservableSnapshot<\n  TContext,\n  TInput extends NonReducibleUnknown\n> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservableActorLogic<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\nexport type ObservableActorRef<TContext> = ActorRefFromLogic<\n  ObservableActorLogic<TContext, any>\n>;\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nexport function fromObservable<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  observableCreator: ({\n    input,\n    system,\n    self\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput, TEmitted> {\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput, TEmitted> = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...state }) => state,\n    restoreSnapshot: (state) => ({\n      ...(state as any),\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nexport function fromEventObservable<\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  lazyObservable: ({\n    input,\n    system,\n    self,\n    emit\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TEvent>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TEvent>\n): ObservableActorLogic<TEvent, TInput, TEmitted> {\n  // TODO: event types\n  const logic: ObservableActorLogic<TEvent, TInput, TEmitted> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...snapshot }) => snapshot,\n    restoreSnapshot: (snapshot: any) => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\nexport type PromiseActorLogic<\n  TOutput,\n  TInput = unknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  AnyActorSystem,\n  TEmitted // TEmitted\n>;\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\nexport type PromiseActorRef<TOutput> = ActorRefFromLogic<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\nconst controllerMap = new WeakMap<AnyActorRef, AbortController>();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromPromise<\n  TOutput,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  promiseCreator: ({\n    input,\n    system,\n    self,\n    signal,\n    emit\n  }: {\n    /** Data that was provided to the promise actor */\n    input: TInput;\n    /** The actor system to which the promise actor belongs */\n    system: AnyActorSystem;\n    /** The parent actor of the promise actor */\n    self: PromiseActorRef<TOutput>;\n    signal: AbortSignal;\n    emit: (emitted: TEmitted) => void;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput, TEmitted> {\n  const logic: PromiseActorLogic<TOutput, TInput, TEmitted> = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP: {\n          controllerMap.get(scope.self)?.abort();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        }\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system, emit }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({\n          input: state.input!,\n          system,\n          self,\n          signal: controller.signal,\n          emit\n        })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_RESOLVE,\n            data: response\n          });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_REJECT,\n            data: errorData\n          });\n        }\n      );\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n","import { MachineSnapshot } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { NULL_EVENT, STATE_DELIMITER } from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { memo } from './memo.ts';\nimport {\n  BuiltinAction,\n  formatInitialTransition,\n  formatTransition,\n  formatTransitions,\n  getCandidates,\n  getDelayedTransitions\n} from './stateUtils.ts';\nimport type {\n  DelayedTransitionDefinition,\n  EventObject,\n  InitialTransitionDefinition,\n  InvokeDefinition,\n  MachineContext,\n  Mapper,\n  StateNodeConfig,\n  StateNodeDefinition,\n  StateNodesConfig,\n  StatesDefinition,\n  TransitionDefinition,\n  TransitionDefinitionMap,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyStateMachine,\n  AnyStateNodeConfig,\n  ProvidedActor,\n  NonReducibleUnknown,\n  EventDescriptor\n} from './types.ts';\nimport {\n  createInvokeId,\n  mapValues,\n  toArray,\n  toTransitionConfigArray\n} from './utils.ts';\n\nconst EMPTY_OBJECT = {};\n\nconst toSerializableAction = (action: UnknownAction) => {\n  if (typeof action === 'string') {\n    return { type: action };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return { type: (action as BuiltinAction).type };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\n\ninterface StateNodeOptions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  _key: string;\n  _parent?: StateNode<TContext, TEvent>;\n  _machine: AnyStateMachine;\n}\n\nexport class StateNode<\n  TContext extends MachineContext = MachineContext,\n  TEvent extends EventObject = EventObject\n> {\n  /**\n   * The relative key of the state node, which represents its location in the\n   * overall state value.\n   */\n  public key: string;\n  /** The unique ID of the state node. */\n  public id: string;\n  /**\n   * The type of this state node:\n   *\n   * - `'atomic'` - no child state nodes\n   * - `'compound'` - nested child state nodes (XOR)\n   * - `'parallel'` - orthogonal nested child state nodes (AND)\n   * - `'history'` - history state node\n   * - `'final'` - final state node\n   */\n  public type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /** The string path from the root machine node to this node. */\n  public path: string[];\n  /** The child state nodes. */\n  public states: StateNodesConfig<TContext, TEvent>;\n  /**\n   * The type of history on this state node. Can be:\n   *\n   * - `'shallow'` - recalls only top-level historical state value\n   * - `'deep'` - recalls historical state value at all levels\n   */\n  public history: false | 'shallow' | 'deep';\n  /** The action(s) to be executed upon entering the state node. */\n  public entry: UnknownAction[];\n  /** The action(s) to be executed upon exiting the state node. */\n  public exit: UnknownAction[];\n  /** The parent state node. */\n  public parent?: StateNode<TContext, TEvent>;\n  /** The root machine node. */\n  public machine: StateMachine<\n    TContext,\n    TEvent,\n    any, // children\n    any, // actor\n    any, // action\n    any, // guard\n    any, // delay\n    any, // state value\n    any, // tag\n    any, // input\n    any, // output\n    any, // emitted\n    any, // meta\n    any // state schema\n  >;\n  /**\n   * The meta data associated with this state node, which will be returned in\n   * State instances.\n   */\n  public meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a\n   * final state node.\n   */\n  public output?:\n    | Mapper<MachineContext, EventObject, unknown, EventObject>\n    | NonReducibleUnknown;\n\n  /**\n   * The order this state node appears. Corresponds to the implicit document\n   * order.\n   */\n  public order: number = -1;\n\n  public description?: string;\n\n  public tags: string[] = [];\n  public transitions!: Map<string, TransitionDefinition<TContext, TEvent>[]>;\n  public always?: Array<TransitionDefinition<TContext, TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO, // actors\n      TODO, // actions\n      TODO, // guards\n      TODO, // delays\n      TODO, // tags\n      TODO, // output\n      TODO, // emitted\n      TODO // meta\n    >,\n    options: StateNodeOptions<TContext, TEvent>\n  ) {\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id =\n      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type =\n      this.config.type ||\n      (this.config.states && Object.keys(this.config.states).length\n        ? 'compound'\n        : this.config.history\n          ? 'history'\n          : 'atomic');\n    this.description = this.config.description;\n\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n\n    this.states = (\n      this.config.states\n        ? mapValues(\n            this.config.states,\n            (stateConfig: AnyStateNodeConfig, key) => {\n              const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n              });\n              return stateNode;\n            }\n          )\n        : EMPTY_OBJECT\n    ) as StateNodesConfig<TContext, TEvent>;\n\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\n        `No initial state specified for compound state node \"#${\n          this.id\n        }\". Try adding { initial: \"${\n          Object.keys(this.states)[0]\n        }\" } to the state config.`\n      );\n    }\n\n    // History config\n    this.history =\n      this.config.history === true ? 'shallow' : this.config.history || false;\n\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n\n    this.meta = this.config.meta;\n    this.output =\n      this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  public _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map((t) =>\n        formatTransition(this, NULL_EVENT, t)\n      );\n    }\n\n    Object.keys(this.states).forEach((key) => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  public get definition(): StateNodeDefinition<TContext, TEvent> {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial\n        ? {\n            target: this.initial.target,\n            source: this,\n            actions: this.initial.actions.map(toSerializableAction),\n            eventType: null as any,\n            reenter: false,\n            toJSON: () => ({\n              target: this.initial.target.map((t) => `#${t.id}`),\n              source: `#${this.id}`,\n              actions: this.initial.actions.map(toSerializableAction),\n              eventType: null as any\n            })\n          }\n        : undefined,\n      history: this.history,\n      states: mapValues(this.states, (state: StateNode<TContext, TEvent>) => {\n        return state.definition;\n      }) as StatesDefinition<TContext, TEvent>,\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map((t) => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  public toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  public get invoke(): Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string,\n      TODO, // TEmitted\n      TODO // TMeta\n    >\n  > {\n    return memo(this, 'invoke', () =>\n      toArray(this.config.invoke).map((invokeConfig, i) => {\n        const { src, systemId } = invokeConfig;\n        const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n        const sourceName =\n          typeof src === 'string'\n            ? src\n            : `xstate.invoke.${createInvokeId(this.id, i)}`;\n\n        return {\n          ...invokeConfig,\n          src: sourceName,\n          id: resolvedId,\n          systemId: systemId,\n          toJSON() {\n            const { onDone, onError, ...invokeDefValues } = invokeConfig;\n            return {\n              ...invokeDefValues,\n              type: 'xstate.invoke',\n              src: sourceName,\n              id: resolvedId\n            };\n          }\n        } as InvokeDefinition<\n          TContext,\n          TEvent,\n          ProvidedActor,\n          ParameterizedObject,\n          ParameterizedObject,\n          string,\n          TODO, // TEmitted\n          TODO // TMeta\n        >;\n      })\n    );\n  }\n\n  /** The mapping of events to transitions. */\n  public get on(): TransitionDefinitionMap<TContext, TEvent> {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n\n      return [...transitions]\n        .flatMap(([descriptor, t]) => t.map((t) => [descriptor, t] as const))\n        .reduce(\n          (map: any, [descriptor, transition]) => {\n            map[descriptor] = map[descriptor] || [];\n            map[descriptor].push(transition);\n            return map;\n          },\n          {} as TransitionDefinitionMap<TContext, TEvent>\n        );\n    });\n  }\n\n  public get after(): Array<DelayedTransitionDefinition<TContext, TEvent>> {\n    return memo(\n      this,\n      'delayedTransitions',\n      () => getDelayedTransitions(this) as any\n    );\n  }\n\n  public get initial(): InitialTransitionDefinition<TContext, TEvent> {\n    return memo(this, 'initial', () =>\n      formatInitialTransition(this, this.config.initial)\n    );\n  }\n\n  /** @internal */\n  public next(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any, // TMeta\n      any // TStateSchema\n    >,\n    event: TEvent\n  ): TransitionDefinition<TContext, TEvent>[] | undefined {\n    const eventType = event.type;\n    const actions: UnknownAction[] = [];\n\n    let selectedTransition: TransitionDefinition<TContext, TEvent> | undefined;\n\n    const candidates: Array<TransitionDefinition<TContext, TEvent>> = memo(\n      this,\n      `candidates-${eventType}`,\n      () => getCandidates(this, eventType)\n    );\n\n    for (const candidate of candidates) {\n      const { guard } = candidate;\n      const resolvedContext = snapshot.context;\n\n      let guardPassed = false;\n\n      try {\n        guardPassed =\n          !guard ||\n          evaluateGuard<TContext, TEvent>(\n            guard,\n            resolvedContext,\n            event,\n            snapshot\n          );\n      } catch (err: any) {\n        const guardType =\n          typeof guard === 'string'\n            ? guard\n            : typeof guard === 'object'\n              ? guard.type\n              : undefined;\n        throw new Error(\n          `Unable to evaluate guard ${\n            guardType ? `'${guardType}' ` : ''\n          }in transition for event '${eventType}' in state node '${\n            this.id\n          }':\\n${err.message}`\n        );\n      }\n\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  public get events(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'events', () => {\n      const { states } = this;\n      const events = new Set(this.ownEvents);\n\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  public get ownEvents(): Array<EventDescriptor<TEvent>> {\n    const keys = Object.keys(Object.fromEntries(this.transitions));\n    const events = new Set(\n      keys.filter((descriptor) => {\n        return this.transitions\n          .get(descriptor)!\n          .some(\n            (transition) =>\n              !(\n                !transition.target &&\n                !transition.actions.length &&\n                !transition.reenter\n              )\n          );\n      })\n    );\n\n    return Array.from(events);\n  }\n}\n","import isDevelopment from '#is-development';\nimport { assign } from './actions.ts';\nimport { $$ACTOR_TYPE, createActor } from './createActor.ts';\nimport { createInitEvent } from './eventUtils.ts';\nimport {\n  createMachineSnapshot,\n  getPersistedSnapshot,\n  MachineSnapshot\n} from './State.ts';\nimport { StateNode } from './StateNode.ts';\nimport {\n  getAllStateNodes,\n  getInitialStateNodes,\n  getStateNodeByPath,\n  getStateNodes,\n  isInFinalState,\n  isStateId,\n  macrostep,\n  microstep,\n  resolveActionsAndContext,\n  resolveStateValue,\n  transitionNode\n} from './stateUtils.ts';\nimport { AnyActorSystem } from './system.ts';\nimport type {\n  ActorLogic,\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  DoNotInfer,\n  Equals,\n  EventDescriptor,\n  EventObject,\n  HistoryValue,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineImplementationsSimplified,\n  MetaObject,\n  ParameterizedObject,\n  ProvidedActor,\n  Snapshot,\n  SnapshotFrom,\n  StateMachineDefinition,\n  StateValue,\n  TransitionDefinition,\n  ResolvedStateMachineTypes,\n  StateSchema,\n  SnapshotStatus\n} from './types.ts';\nimport { resolveReferencedActor, toStatePath } from './utils.ts';\n\nconst STATE_IDENTIFIER = '#';\n\nexport class StateMachine<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> implements\n    ActorLogic<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      TInput,\n      AnyActorSystem,\n      TEmitted\n    >\n{\n  /** The machine's own version. */\n  public version?: string;\n\n  public schemas: unknown;\n\n  public implementations: MachineImplementationsSimplified<TContext, TEvent>;\n\n  /** @internal */\n  public __xstatenode = true as const;\n\n  /** @internal */\n  public idMap: Map<string, StateNode<TContext, TEvent>> = new Map();\n\n  public root: StateNode<TContext, TEvent>;\n\n  public id: string;\n\n  public states: StateNode<TContext, TEvent>['states'];\n  public events: Array<EventDescriptor<TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: MachineConfig<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      TOutput,\n      any, // TEmitted\n      any // TMeta\n    > & {\n      schemas?: unknown;\n    },\n    implementations?: MachineImplementationsSimplified<TContext, TEvent>\n  ) {\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this as any\n    });\n\n    this.root._initialize();\n\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n\n    if (\n      isDevelopment &&\n      !('output' in this.root) &&\n      Object.values(this.states).some(\n        (state) => state.type === 'final' && 'output' in state\n      )\n    ) {\n      console.warn(\n        'Missing `machine.output` declaration (top-level final state with output detected)'\n      );\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  public provide(\n    implementations: InternalMachineImplementations<\n      ResolvedStateMachineTypes<\n        TContext,\n        DoNotInfer<TEvent>,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        TEmitted\n      >\n    >\n  ): StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TStateValue,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta,\n    TStateSchema\n  > {\n    const { actions, guards, actors, delays } = this.implementations;\n\n    return new StateMachine(this.config, {\n      actions: { ...actions, ...implementations.actions },\n      guards: { ...guards, ...implementations.guards },\n      actors: { ...actors, ...implementations.actors },\n      delays: { ...delays, ...implementations.delays }\n    });\n  }\n\n  public resolveState(\n    config: {\n      value: StateValue;\n      context?: TContext;\n      historyValue?: HistoryValue<TContext, TEvent>;\n      status?: SnapshotStatus;\n      output?: TOutput;\n      error?: unknown;\n    } & (Equals<TContext, MachineContext> extends false\n      ? { context: unknown }\n      : {})\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(\n      getStateNodes(this.root, resolvedStateValue)\n    );\n\n    return createMachineSnapshot(\n      {\n        _nodes: [...nodeSet],\n        context: config.context || ({} as TContext),\n        children: {},\n        status: isInFinalState(nodeSet, this.root)\n          ? 'done'\n          : config.status || 'active',\n        output: config.output,\n        error: config.error,\n        historyValue: config.historyValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  public transition(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent,\n    actorScope: ActorScope<typeof snapshot, TEvent, AnyActorSystem, TEmitted>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    return macrostep(snapshot, event, actorScope, [])\n      .snapshot as typeof snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  public microstep(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent,\n    actorScope: AnyActorScope\n  ): Array<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  > {\n    return macrostep(snapshot, event, actorScope, []).microstates;\n  }\n\n  public getTransitionData(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent\n  ): Array<TransitionDefinition<TContext, TEvent>> {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  private getPreInitialState(\n    actorScope: AnyActorScope,\n    initEvent: any,\n    internalQueue: AnyEventObject[]\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const { context } = this.config;\n\n    const preInitial = createMachineSnapshot(\n      {\n        context:\n          typeof context !== 'function' && context ? context : ({} as TContext),\n        _nodes: [this.root],\n        children: {},\n        status: 'active'\n      },\n      this\n    );\n\n    if (typeof context === 'function') {\n      const assignment = ({ spawn, event, self }: any) =>\n        context({ spawn, input: event.input, self });\n      return resolveActionsAndContext(\n        preInitial,\n        initEvent,\n        actorScope,\n        [assign(assignment)],\n        internalQueue,\n        undefined\n      ) as SnapshotFrom<this>;\n    }\n\n    return preInitial as SnapshotFrom<this>;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  public getInitialSnapshot(\n    actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >,\n    input?: TInput\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const initEvent = createInitEvent(input) as unknown as TEvent; // TODO: fix;\n    const internalQueue: AnyEventObject[] = [];\n    const preInitialState = this.getPreInitialState(\n      actorScope,\n      initEvent,\n      internalQueue\n    );\n    const nextState = microstep(\n      [\n        {\n          target: [...getInitialStateNodes(this.root)],\n          source: this.root,\n          reenter: true,\n          actions: [],\n          eventType: null as any,\n          toJSON: null as any // TODO: fix\n        }\n      ],\n      preInitialState,\n      actorScope,\n      initEvent,\n      true,\n      internalQueue\n    );\n\n    const { snapshot: macroState } = macrostep(\n      nextState,\n      initEvent as AnyEventObject,\n      actorScope,\n      internalQueue\n    );\n\n    return macroState as SnapshotFrom<this>;\n  }\n\n  public start(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  ): void {\n    Object.values(snapshot.children as Record<string, AnyActorRef>).forEach(\n      (child: any) => {\n        if (child.getSnapshot().status === 'active') {\n          child.start();\n        }\n      }\n    );\n  }\n\n  public getStateNodeById(stateId: string): StateNode<TContext, TEvent> {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0])\n      ? fullPath[0].slice(STATE_IDENTIFIER.length)\n      : fullPath[0];\n\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\n        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`\n      );\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n\n  public get definition(): StateMachineDefinition<TContext, TEvent> {\n    return this.root.definition;\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  public getPersistedSnapshot(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    options?: unknown\n  ) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n\n  public restoreSnapshot(\n    snapshot: Snapshot<unknown>,\n    _actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const children: Record<string, AnyActorRef> = {};\n    const snapshotChildren: Record<\n      string,\n      {\n        src: string | AnyActorLogic;\n        snapshot: Snapshot<unknown>;\n        syncSnapshot?: boolean;\n        systemId?: string;\n      }\n    > = (snapshot as any).children;\n\n    Object.keys(snapshotChildren).forEach((actorId) => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n\n      const logic =\n        typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n\n      if (!logic) {\n        return;\n      }\n\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n\n      children[actorId] = actorRef;\n    });\n\n    function resolveHistoryReferencedState(\n      root: StateNode<TContext, TEvent>,\n      referenced: { id: string } | StateNode<TContext, TEvent>\n    ) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        if (isDevelopment) {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n\n    function reviveHistoryValue(\n      root: StateNode<TContext, TEvent>,\n      historyValue: Record<\n        string,\n        ({ id: string } | StateNode<TContext, TEvent>)[]\n      >\n    ): HistoryValue<TContext, TEvent> {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived: HistoryValue<TContext, TEvent> = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n\n          if (!resolved) {\n            continue;\n          }\n\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n\n    const revivedHistoryValue = reviveHistoryValue(\n      this.root,\n      (snapshot as any).historyValue\n    );\n\n    const restoredSnapshot = createMachineSnapshot(\n      {\n        ...(snapshot as any),\n        children,\n        _nodes: Array.from(\n          getAllStateNodes(getStateNodes(this.root, (snapshot as any).value))\n        ),\n        historyValue: revivedHistoryValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n\n    const seen = new Set();\n\n    function reviveContext(\n      contextPart: Record<string, unknown>,\n      children: Record<string, AnyActorRef>\n    ) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value: unknown = contextPart[key];\n\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[(value as any).id];\n            continue;\n          }\n          reviveContext(value as typeof contextPart, children);\n        }\n      }\n    }\n\n    reviveContext(restoredSnapshot.context, children);\n\n    return restoredSnapshot;\n  }\n}\n","import { StateMachine } from './StateMachine.ts';\nimport {\n  ResolvedStateMachineTypes,\n  TODO,\n  AnyActorRef,\n  EventObject,\n  AnyEventObject,\n  Cast,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineTypes,\n  NonReducibleUnknown,\n  ParameterizedObject,\n  ProvidedActor,\n  StateValue,\n  ToChildren,\n  MetaObject\n} from './types.ts';\n\ntype TestValue =\n  | string\n  | {\n      [k: string]: TestValue | undefined;\n    };\n\ntype _GroupTestValues<TTestValue extends string | TestValue> =\n  TTestValue extends string\n    ? TTestValue extends `${string}.${string}`\n      ? [never, never]\n      : [TTestValue, never]\n    : [never, TTestValue];\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nexport function createMachine<\n  TContext extends MachineContext,\n  TEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput extends NonReducibleUnknown,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  // it's important to have at least one default type parameter here\n  // it allows us to benefit from contextual type instantiation as it makes us to pass the hasInferenceCandidatesOrDefault check in the compiler\n  // we should be able to remove this when we start inferring TConfig, with it we'll always have an inference candidate\n  _ = any\n>(\n  config: {\n    types?: MachineTypes<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TTag,\n      TInput,\n      TOutput,\n      TEmitted,\n      TMeta\n    >;\n    schemas?: unknown;\n  } & MachineConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta\n  >,\n  implementations?: InternalMachineImplementations<\n    ResolvedStateMachineTypes<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TTag,\n      TEmitted\n    >\n  >\n): StateMachine<\n  TContext,\n  TEvent,\n  Cast<ToChildren<TActor>, Record<string, AnyActorRef | undefined>>,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay,\n  StateValue,\n  TTag & string,\n  TInput,\n  TOutput,\n  TEmitted,\n  TMeta, // TMeta\n  TODO // TStateSchema\n> {\n  return new StateMachine<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any, // TEmitted\n    any, // TMeta\n    any // TStateSchema\n  >(config as any, implementations as any);\n}\n","import { createActor } from './createActor.ts';\nimport {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorScope,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  SnapshotFrom\n} from './types.ts';\n\n/** @internal */\nexport function createInertActorScope<T extends AnyActorLogic>(\n  actorLogic: T\n): AnyActorScope {\n  const self = createActor(actorLogic as AnyActorLogic);\n  const inertActorScope: ActorScope<\n    SnapshotFrom<T>,\n    EventFromLogic<T>,\n    any,\n    EmittedFrom<T>\n  > = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n\n  return inertActorScope;\n}\n\n/** @deprecated Use `initialTransition(…)` instead. */\nexport function getInitialSnapshot<T extends AnyActorLogic>(\n  actorLogic: T,\n  ...[input]: undefined extends InputFrom<T>\n    ? [input?: InputFrom<T>]\n    : [input: InputFrom<T>]\n): SnapshotFrom<T> {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nexport function getNextSnapshot<T extends AnyActorLogic>(\n  actorLogic: T,\n  snapshot: SnapshotFrom<T>,\n  event: EventFromLogic<T>\n): SnapshotFrom<T> {\n  const inertActorScope = createInertActorScope(actorLogic);\n  (inertActorScope.self as any)._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n","import isDevelopment from '#is-development';\nimport { AnyActorRef, SnapshotFrom, Subscription } from './types.ts';\n\ninterface WaitForOptions {\n  /**\n   * How long to wait before rejecting, if no emitted state satisfies the\n   * predicate.\n   *\n   * @defaultValue Infinity\n   */\n  timeout: number;\n\n  /** A signal which stops waiting when aborted. */\n  signal?: AbortSignal;\n}\n\nconst defaultWaitForOptions: WaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nexport function waitFor<TActorRef extends AnyActorRef>(\n  actorRef: TActorRef,\n  predicate: (emitted: SnapshotFrom<TActorRef>) => boolean,\n  options?: Partial<WaitForOptions>\n): Promise<SnapshotFrom<TActorRef>> {\n  const resolvedOptions: WaitForOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const { signal } = resolvedOptions;\n    if (signal?.aborted) {\n      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    if (isDevelopment && resolvedOptions.timeout < 0) {\n      console.error(\n        '`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.'\n      );\n    }\n    const handle =\n      resolvedOptions.timeout === Infinity\n        ? undefined\n        : setTimeout(() => {\n            dispose();\n            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n          }, resolvedOptions.timeout);\n\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal!.removeEventListener('abort', abortListener);\n      }\n    };\n\n    function checkEmitted(emitted: SnapshotFrom<TActorRef>) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener: () => void | undefined;\n    // eslint-disable-next-line prefer-const\n    let sub: Subscription | undefined; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: (err) => {\n        dispose();\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n","import { Clock } from './system.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface SimulatedClock extends Clock {\n  start(speed: number): void;\n  increment(ms: number): void;\n  set(ms: number): void;\n}\n\ninterface SimulatedTimeout {\n  start: number;\n  timeout: number;\n  fn: (...args: any[]) => void;\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class SimulatedClock implements SimulatedClock {\n  private timeouts: Map<number, SimulatedTimeout> = new Map();\n  private _now: number = 0;\n  private _id: number = 0;\n  private _flushing = false;\n  private _flushingInvalidated = false;\n\n  public now() {\n    return this._now;\n  }\n  private getId() {\n    return this._id++;\n  }\n  public setTimeout(fn: (...args: any[]) => void, timeout: number) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  public clearTimeout(id: number) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  public set(time: number) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n\n    this._now = time;\n    this.flushTimeouts();\n  }\n  private flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n\n    const sorted = [...this.timeouts].sort(\n      ([_idA, timeoutA], [_idB, timeoutB]) => {\n        const endA = timeoutA.start + timeoutA.timeout;\n        const endB = timeoutB.start + timeoutB.timeout;\n        return endB > endA ? -1 : 1;\n      }\n    );\n\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n\n    this._flushing = false;\n  }\n  public increment(ms: number): void {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n","import { EventDescriptor, EventObject, ExtractEvent } from './types.ts';\nimport { matchesEventDescriptor, toArray } from './utils.ts';\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nexport function assertEvent<\n  TEvent extends EventObject,\n  TAssertedDescriptor extends EventDescriptor<TEvent>\n>(\n  event: TEvent,\n  type: TAssertedDescriptor | readonly TAssertedDescriptor[]\n): asserts event is ExtractEvent<TEvent, TAssertedDescriptor> {\n  const types = toArray(type);\n\n  const matches = types.some((descriptor) =>\n    matchesEventDescriptor(event.type, descriptor as string)\n  );\n\n  if (!matches) {\n    const typesText =\n      types.length === 1\n        ? `type matching \"${types[0]}\"`\n        : `one of types matching \"${types.join('\", \"')}\"`;\n    throw new Error(\n      `Expected event ${JSON.stringify(event)} to have ${typesText}`\n    );\n  }\n}\n","import { createInertActorScope } from './getNextSnapshot';\nimport {\n  AnyActorLogic,\n  EventFromLogic,\n  InputFrom,\n  SnapshotFrom,\n  ExecutableActionsFrom\n} from './types';\n\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */\nexport function transition<T extends AnyActorLogic>(\n  logic: T,\n  snapshot: SnapshotFrom<T>,\n  event: EventFromLogic<T>\n): [nextSnapshot: SnapshotFrom<T>, actions: ExecutableActionsFrom<T>[]] {\n  const executableActions = [] as ExecutableActionsFrom<T>[];\n\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = (action) => {\n    executableActions.push(action as ExecutableActionsFrom<T>);\n  };\n\n  const nextSnapshot = logic.transition(snapshot, event, actorScope);\n\n  return [nextSnapshot, executableActions];\n}\n\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */\nexport function initialTransition<T extends AnyActorLogic>(\n  logic: T,\n  ...[input]: undefined extends InputFrom<T>\n    ? [input?: InputFrom<T>]\n    : [input: InputFrom<T>]\n): [SnapshotFrom<T>, ExecutableActionsFrom<T>[]] {\n  const executableActions = [] as ExecutableActionsFrom<T>[];\n\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = (action) => {\n    executableActions.push(action as ExecutableActionsFrom<T>);\n  };\n\n  const nextSnapshot = logic.getInitialSnapshot(\n    actorScope,\n    input\n  ) as SnapshotFrom<T>;\n\n  return [nextSnapshot, executableActions];\n}\n","import { StateMachine } from './StateMachine';\nimport { assign } from './actions/assign';\nimport { cancel } from './actions/cancel';\nimport { emit } from './actions/emit';\nimport { enqueueActions } from './actions/enqueueActions';\nimport { log } from './actions/log';\nimport { raise } from './actions/raise';\nimport { sendTo } from './actions/send';\nimport { spawnChild } from './actions/spawnChild';\nimport { stopChild } from './actions/stopChild';\nimport { createMachine } from './createMachine';\nimport { GuardPredicate } from './guards';\n\nimport {\n  ActionFunction,\n  AnyActorRef,\n  AnyEventObject,\n  Cast,\n  DelayConfig,\n  EventObject,\n  Invert,\n  IsNever,\n  MachineConfig,\n  MachineContext,\n  MetaObject,\n  NonReducibleUnknown,\n  ParameterizedObject,\n  SetupTypes,\n  StateNodeConfig,\n  StateSchema,\n  ToChildren,\n  ToStateValue,\n  UnknownActorLogic,\n  Values\n} from './types';\n\ntype ToParameterizedObject<\n  TParameterizedMap extends Record<\n    string,\n    ParameterizedObject['params'] | undefined\n  >\n> = Values<{\n  [K in keyof TParameterizedMap as K & string]: {\n    type: K & string;\n    params: TParameterizedMap[K];\n  };\n}>;\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\ntype ToProvidedActor<\n  TChildrenMap extends Record<string, string>,\n  TActors extends Record<string, UnknownActorLogic>\n> = Values<{\n  [K in keyof TActors as K & string]: {\n    src: K & string;\n    logic: TActors[K];\n    id: IsNever<TChildrenMap> extends true\n      ? string | undefined\n      : K extends keyof Invert<TChildrenMap>\n        ? Invert<TChildrenMap>[K] & string\n        : string | undefined;\n  };\n}>;\n\n// used to keep only StateSchema relevant keys\n// this helps with type serialization as it makes the inferred type much shorter when dealing with huge configs\ntype ToStateSchema<TSchema extends StateSchema> = {\n  -readonly [K in keyof TSchema as K & ('id' | 'states')]: K extends 'states'\n    ? {\n        [SK in keyof TSchema['states']]: ToStateSchema<\n          NonNullable<TSchema['states'][SK]>\n        >;\n      }\n    : TSchema[K];\n};\n\ntype RequiredSetupKeys<TChildrenMap> =\n  IsNever<keyof TChildrenMap> extends true ? never : 'actors';\n\ntype SetupReturn<\n  TContext extends MachineContext,\n  TEvent extends AnyEventObject,\n  TActors extends Record<string, UnknownActorLogic>,\n  TChildrenMap extends Record<string, string>,\n  TActions extends Record<string, ParameterizedObject['params'] | undefined>,\n  TGuards extends Record<string, ParameterizedObject['params'] | undefined>,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput extends NonReducibleUnknown,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject\n> = {\n  extend: <\n    TExtendActions extends Record<\n      string,\n      ParameterizedObject['params'] | undefined\n    > = {},\n    TExtendGuards extends Record<\n      string,\n      ParameterizedObject['params'] | undefined\n    > = {},\n    TExtendDelays extends string = never\n  >({\n    actions,\n    guards,\n    delays\n  }: {\n    actions?: {\n      [K in keyof TExtendActions]: ActionFunction<\n        TContext,\n        TEvent,\n        TEvent,\n        TExtendActions[K],\n        ToProvidedActor<TChildrenMap, TActors>,\n        ToParameterizedObject<TActions & TExtendActions>,\n        ToParameterizedObject<TGuards & TExtendGuards>,\n        TDelay | TExtendDelays,\n        TEmitted\n      >;\n    };\n    guards?: {\n      [K in keyof TExtendGuards]: GuardPredicate<\n        TContext,\n        TEvent,\n        TExtendGuards[K],\n        ToParameterizedObject<TGuards & TExtendGuards>\n      >;\n    };\n    delays?: {\n      [K in TExtendDelays]: DelayConfig<\n        TContext,\n        TEvent,\n        ToParameterizedObject<TActions & TExtendActions>['params'],\n        TEvent\n      >;\n    };\n  }) => SetupReturn<\n    TContext,\n    TEvent,\n    TActors,\n    TChildrenMap,\n    TActions & TExtendActions,\n    TGuards & TExtendGuards,\n    TDelay | TExtendDelays,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta\n  >;\n  /**\n   * Creates a state config that is strongly typed. This state config can be\n   * used to create a machine.\n   *\n   * @example\n   *\n   * ```ts\n   * const lightMachineSetup = setup({\n   *   // ...\n   * });\n   *\n   * const green = lightMachineSetup.createStateConfig({\n   *   on: {\n   *     timer: {\n   *       actions: 'doSomething'\n   *     }\n   *   }\n   * });\n   *\n   * const machine = lightMachineSetup.createMachine({\n   *   initial: 'green',\n   *   states: {\n   *     green,\n   *     yellow,\n   *     red\n   *   }\n   * });\n   * ```\n   */\n  createStateConfig: <\n    TStateConfig extends StateNodeConfig<\n      TContext,\n      TEvent,\n      ToProvidedActor<TChildrenMap, TActors>,\n      ToParameterizedObject<TActions>,\n      ToParameterizedObject<TGuards>,\n      TDelay,\n      TTag,\n      unknown,\n      TEmitted,\n      TMeta\n    >\n  >(\n    config: TStateConfig\n  ) => TStateConfig;\n  /**\n   * Creates a type-safe action.\n   *\n   * @example\n   *\n   * ```ts\n   * const machineSetup = setup({\n   *   // ...\n   * });\n   *\n   * const action = machineSetup.createAction(({ context, event }) => {\n   *   console.log(context.count, event.value);\n   * });\n   *\n   * const incrementAction = machineSetup.createAction(\n   *   assign({ count: ({ context }) => context.count + 1 })\n   * );\n   *\n   * const machine = machineSetup.createMachine({\n   *   context: { count: 0 },\n   *   entry: [action, incrementAction]\n   * });\n   * ```\n   */\n  createAction: (\n    action: ActionFunction<\n      TContext,\n      TEvent,\n      TEvent,\n      unknown,\n      ToProvidedActor<TChildrenMap, TActors>,\n      ToParameterizedObject<TActions>,\n      ToParameterizedObject<TGuards>,\n      TDelay,\n      TEmitted\n    >\n  ) => typeof action;\n\n  createMachine: <\n    const TConfig extends MachineConfig<\n      TContext,\n      TEvent,\n      ToProvidedActor<TChildrenMap, TActors>,\n      ToParameterizedObject<TActions>,\n      ToParameterizedObject<TGuards>,\n      TDelay,\n      TTag,\n      TInput,\n      TOutput,\n      TEmitted,\n      TMeta\n    >\n  >(\n    config: TConfig\n  ) => StateMachine<\n    TContext,\n    TEvent,\n    Cast<\n      ToChildren<ToProvidedActor<TChildrenMap, TActors>>,\n      Record<string, AnyActorRef | undefined>\n    >,\n    ToProvidedActor<TChildrenMap, TActors>,\n    ToParameterizedObject<TActions>,\n    ToParameterizedObject<TGuards>,\n    TDelay,\n    ToStateValue<TConfig>,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta,\n    ToStateSchema<TConfig>\n  >;\n\n  assign: typeof assign<\n    TContext,\n    TEvent,\n    undefined,\n    TEvent,\n    ToProvidedActor<TChildrenMap, TActors>\n  >;\n  sendTo: <TTargetActor extends AnyActorRef>(\n    ...args: Parameters<\n      typeof sendTo<\n        TContext,\n        TEvent,\n        undefined,\n        TTargetActor,\n        TEvent,\n        TDelay,\n        TDelay\n      >\n    >\n  ) => ReturnType<\n    typeof sendTo<\n      TContext,\n      TEvent,\n      undefined,\n      TTargetActor,\n      TEvent,\n      TDelay,\n      TDelay\n    >\n  >;\n  raise: typeof raise<TContext, TEvent, TEvent, undefined, TDelay, TDelay>;\n  log: typeof log<TContext, TEvent, undefined, TEvent>;\n  cancel: typeof cancel<TContext, TEvent, undefined, TEvent>;\n  stopChild: typeof stopChild<TContext, TEvent, undefined, TEvent>;\n  enqueueActions: typeof enqueueActions<\n    TContext,\n    TEvent,\n    undefined,\n    TEvent,\n    ToProvidedActor<TChildrenMap, TActors>,\n    ToParameterizedObject<TActions>,\n    ToParameterizedObject<TGuards>,\n    TDelay,\n    TEmitted\n  >;\n  emit: typeof emit<TContext, TEvent, undefined, TEvent, TEmitted>;\n  spawnChild: typeof spawnChild<\n    TContext,\n    TEvent,\n    undefined,\n    TEvent,\n    ToProvidedActor<TChildrenMap, TActors>\n  >;\n};\n\nexport function setup<\n  TContext extends MachineContext,\n  TEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TActors extends Record<string, UnknownActorLogic> = {},\n  TChildrenMap extends Record<string, string> = {},\n  TActions extends Record<\n    string,\n    ParameterizedObject['params'] | undefined\n  > = {},\n  TGuards extends Record<\n    string,\n    ParameterizedObject['params'] | undefined\n  > = {},\n  TDelay extends string = never,\n  TTag extends string = string,\n  TInput = NonReducibleUnknown,\n  TOutput extends NonReducibleUnknown = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject,\n  TMeta extends MetaObject = MetaObject\n>({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}: {\n  schemas?: unknown;\n  types?: SetupTypes<\n    TContext,\n    TEvent,\n    TChildrenMap,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta\n  >;\n  actors?: {\n    // union here enforces that all configured children have to be provided in actors\n    // it makes those values required here\n    [K in keyof TActors | Values<TChildrenMap>]: K extends keyof TActors\n      ? TActors[K]\n      : never;\n  };\n  actions?: {\n    [K in keyof TActions]: ActionFunction<\n      TContext,\n      TEvent,\n      TEvent,\n      TActions[K],\n      ToProvidedActor<TChildrenMap, TActors>,\n      ToParameterizedObject<TActions>,\n      ToParameterizedObject<TGuards>,\n      TDelay,\n      TEmitted\n    >;\n  };\n  guards?: {\n    [K in keyof TGuards]: GuardPredicate<\n      TContext,\n      TEvent,\n      TGuards[K],\n      ToParameterizedObject<TGuards>\n    >;\n  };\n  delays?: {\n    [K in TDelay]: DelayConfig<\n      TContext,\n      TEvent,\n      ToParameterizedObject<TActions>['params'],\n      TEvent\n    >;\n  };\n} & {\n  [K in RequiredSetupKeys<TChildrenMap>]: unknown;\n}): SetupReturn<\n  TContext,\n  TEvent,\n  TActors,\n  TChildrenMap,\n  TActions,\n  TGuards,\n  TDelay,\n  TTag,\n  TInput,\n  TOutput,\n  TEmitted,\n  TMeta\n> {\n  return {\n    assign,\n    sendTo,\n    raise,\n    log,\n    cancel,\n    stopChild,\n    enqueueActions,\n    emit,\n    spawnChild,\n    createStateConfig: (config) => config,\n    createAction: (fn) => fn,\n    createMachine: (config) =>\n      (createMachine as any)(\n        { ...config, schemas },\n        {\n          actors,\n          actions,\n          guards,\n          delays\n        }\n      ),\n    extend: (extended) =>\n      setup({\n        schemas,\n        actors,\n        actions: { ...actions, ...extended.actions },\n        guards: { ...guards, ...extended.guards },\n        delays: { ...delays, ...extended.delays }\n      } as any)\n  };\n}\n","import { AnyActorRef, OutputFrom } from './types.ts';\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nexport function toPromise<T extends AnyActorRef>(\n  actor: T\n): Promise<OutputFrom<T>> {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_INIT","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","createDoneStateEvent","id","output","type","createErrorActorEvent","error","actorId","createInitEvent","input","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","key","toStatePath","stateId","isArray","result","segment","i","length","charCodeAt","push","stateValue","isMachineSnapshot","pathToStateValue","statePath","marker","previous","mapValues","collection","iteratee","collectionKeys","toArrayStrict","toArray","undefined","resolveOutput","mapper","context","Array","toTransitionConfigArray","configLike","map","transitionLike","target","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","complete","createInvokeId","stateNodeId","index","resolveReferencedActor","machine","src","match","implementations","actors","indexStr","nodeId","invokeConfig","getStateNodeById","config","invoke","matchesEventDescriptor","eventType","descriptor","endsWith","partialEventTokens","split","eventTokens","tokenIndex","partialEventToken","eventToken","createScheduledEventId","actorRef","sessionId","idCounter","executingCustomAction","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","Set","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","systemId","system","_doneEvent","_deferred","resolvedOptions","parent","syncSnapshot","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","snapshot","_bookId","_register","set","_unregister","delete","get","getAll","fromEntries","entries","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","actionExecutor","action","exec","params","saveExecutingCustomAction","info","Running","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","update","deferredFn","shift","_stopProcedure","_complete","invokeId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","createActor","interpret","resolveCancel","_","actionArgs","actionParams","sendId","executeCancel","actorScope","_args","_params","resolve","execute","resolveSpawn","_actionParams","resolvedId","resolvedInput","cloneMachineSnapshot","executeSpawn","spawnChild","resolveStop","args","actorRefOrString","resolvedActorRef","executeStop","checkStateIn","isStateId","_nodes","some","sn","matches","checkNot","guards","evaluateGuard","checkAnd","guard","checkOr","isInline","resolved","guardArgs","guardParams","check","isAtomicStateNode","stateNode","getChildren","states","filter","getProperAncestors","toStateNode","ancestors","m","getAllStateNodes","stateNodes","nodeSet","adjList","getAdjList","s","has","initialStates","getInitialStateNodesWithTheirAncestors","initialStateNode","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isInFinalState","stateNodeSet","str","getDelayedTransitions","afterConfig","after","delayedTransitions","flatMap","configTransition","resolvedTransition","resolvedDelay","Number","isNaN","afterEvent","delayRef","entry","raise","exit","mutateEntryExit","delayedTransition","formatTransition","transitionConfig","normalizedTarget","reenter","targets","isInternalTarget","getStateNodeByPath","resolvedTarget","message","resolveTarget","actions","t","resolveHistoryDefaultTransition","initial","isHistoryNode","getInitialStateNodes","initialState","ancestor","iter","descStateNode","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","childStateKeys","subStateKey","Boolean","root","concat","reduce","allSubStateNodes","subStateNode","subStateNodes","transitionNode","transitionAtomicNode","subStateKeys","transitionCompoundNode","allInnerTransitions","subStateValue","innerTransitions","transitionParallelNode","getHistoryNodes","isDescendant","parentStateNode","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","from","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","lca","head","tail","findLeastCommonAncestor","transitions","statesToExit","domain","microstep","currentSnapshot","isInitial","internalQueue","mutStateNodeSet","nextSnapshot","changedHistory","sort","a","b","order","exitStateNode","historyNode","predicate","history","resolveActionsAndContext","def","exitStates","statesToEnter","statesForDefaultEntry","addDescendantStatesToEnter","addAncestorStatesToEnter","computeEntrySet","completedNodes","stateNodeToEnter","invokeDef","onSnapshot","initialActions","ancestorMarker","rootCompletionNode","getMachineOutput","enterStates","nextStateNodes","prevStateNodes","nextStateNodeSet","areStateNodeCollectionsEqual","e","doneStateEvent","historyStateNodes","addProperAncestorStatesToEnter","historyDefaultTransition","reentrancyDomain","anc","getAction","actionType","resolveAndExecuteActionsWithContext","extra","retries","intermediateSnapshot","resolvedAction","name","builtinAction","deferredActorIds","retryResolve","macrostep","microstates","addMicrostate","microstate","_transitions","stopChildren","nextEvent","currentEvent","isErr","startsWith","isErrorActorEvent","selectTransitions","shouldSelectEventlessTransitions","selectEventlessTransitions","previousState","getTransitionData","enabledTransitionSet","atomicStates","loop","always","machineSnapshotMatches","testValue","machineSnapshotHasTag","tag","tags","machineSnapshotCan","transitionData","machineSnapshotToJSON","nodes","getMeta","can","hasTag","jsonValues","machineSnapshotGetMeta","acc","meta","createMachineSnapshot","serializeHistoryValue","persistContext","contextPart","copy","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","assign","resolveEmit","eventOrExpr","executeEmit","resolveRaise","delaysMap","delays","resolvedEvent","configDelay","executeRaise","SpecialTargets","resolveSendTo","to","targetActorRef","Parent","Internal","includes","targetId","retryResolveSendTo","executeSendTo","data","sendTo","sendParent","resolveEnqueueActions","collect","enqueueActions","resolveLog","label","executeLog","fromTransition","initialContext","instanceStates","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","emptyLogic","cache","memo","object","memoizedData","EMPTY_OBJECT","toSerializableAction","StateNode","path","description","_key","_machine","join","idMap","stateConfig","_initialize","transitionsConfig","onDone","onError","formatTransitions","definition","version","flat","sourceName","invokeDefValues","_target","formatInitialTransition","selectedTransition","candidates","getCandidates","receivedEventType","eventDescriptor","candidate","resolvedContext","guardPassed","guardType","events","ownEvents","StateMachine","schemas","__xstatenode","provide","resolveState","resolvedStateValue","getPreInitialState","preInitial","preInitialState","macroState","fullPath","relativePath","resolvedStateId","STATE_IDENTIFIER","childrenJson","snapshotChildren","resolveHistoryReferencedState","referenced","actorData","childState","revivedHistoryValue","revived","arr","reviveHistoryValue","restoredSnapshot","seen","reviveContext","createMachine","createInertActorScope","actorLogic","defaultWaitForOptions","Infinity","timeouts","_now","_id","_flushing","_flushingInvalidated","getId","time","flushTimeouts","sorted","_idA","timeoutA","_idB","timeoutB","endA","call","increment","and","types","typesText","JSON","stringify","callback","callbackState","receivers","dispose","sendBack","receive","listener","receiver","lazyObservable","_subscription","observableCreator","promiseCreator","scope","resolvedValue","abort","controller","AbortController","Promise","signal","then","response","errorData","inertActorScope","executableActions","not","or","setup","createStateConfig","createAction","extend","extended","stateIn","actor","reject","res","rej","aborted","reason","done","handle","sub","abortListener","removeEventListener","checkEmitted","emitted","addEventListener"],"mappings":"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"}