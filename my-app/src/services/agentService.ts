import { chatAgent } from '../agents/chatAgent.js'
import { memory, storage, ensureStorageInitialized } from '../config/memory.js'
import { getWorkingMemory, getWorkingMemorySummary, setWorkingMemory } from './workingMemoryService.js'

/**
 * Message type for API responses
 */
export interface AgentMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  createdAt: Date
}

/**
 * Thread type for API responses
 */
export interface AgentThread {
  id: string
  title?: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Agent response type
 */
export interface AgentResponse {
  userMessage: AgentMessage
  assistantMessage: AgentMessage
  threadId: string
  workingMemorySummary?: string
}

// Use the storage initialization from memory config
// This ensures consistent initialization across the app

/**
 * Run the chat agent with user context
 * 
 * @param userId - The authenticated user's ID (used as resourceId for memory isolation)
 * @param threadId - The conversation thread ID
 * @param message - The user's message
 * @param includeWorkingMemory - Whether to include working memory context
 */
export async function runAgent(
  userId: string,
  threadId: string,
  message: string,
  includeWorkingMemory = true
): Promise<AgentResponse> {
  await ensureStorageInitialized()

  // Ensure thread exists
  await getOrCreateThread(threadId, userId)

  // Build the message with optional working memory context
  let enhancedMessage = message
  let workingMemorySummary: string | undefined

  if (includeWorkingMemory) {
    workingMemorySummary = await getWorkingMemorySummary(userId, threadId)
    if (workingMemorySummary && workingMemorySummary.trim().length > 50) {
      enhancedMessage = `${workingMemorySummary}\n\n---\n\nUser Message: ${message}`
    }
  }

  // Verify thread exists and has resourceId before generating
  const thread = await storage.getThreadById({ threadId })
  if (!thread || !thread.resourceId) {
    throw new Error(`Thread ${threadId} not found or missing resourceId. Please ensure thread is created first.`)
  }

  // Generate response using the agent with memory context
  // IMPORTANT: agent.generateLegacy() with threadId and resourceId automatically:
  // 1. Retrieves conversation history (last 20 messages) via Memory instance
  // 2. Performs semantic recall to find relevant past messages
  // 3. Saves both user and assistant messages to memory WITH embeddings
  // 4. The Memory instance handles all persistence and embedding generation
  //
  // The agent's Memory instance is configured with:
  // - storage: PostgresStore or LibSQLStore for persistence
  // - vector: PgVector or LibSQLVector for semantic search
  // - embedder: OpenAI text-embedding-3-small for embeddings
  // - semanticRecall: enabled with topK=3, messageRange=2, scope='resource'
  //
  // When agent.generateLegacy() is called with threadId and resourceId, it automatically:
  // - Saves the user message with embedding
  // - Generates the assistant response
  // - Saves the assistant message with embedding
  // - All messages are persisted and searchable via semantic recall
  // Using generateLegacy() because the model is AI SDK v4 compatible
  console.log(`[AgentService] Generating response for thread ${threadId}, resource ${userId}`)
  console.log(`[AgentService] Using Mastra Memory - messages will be saved automatically with embeddings`)
  
  const response = await chatAgent.generateLegacy(enhancedMessage, {
    resourceId: userId,
    threadId: threadId,
  })
  
  console.log(`[AgentService] Response generated by agent with Memory instance`)
  
  // Verify messages were saved by the agent's Memory instance
  // This confirms that agent.generateLegacy() properly persisted the messages
  try {
    const verifyResult = await (memory as any).recall({
      threadId,
      resourceId: userId,
      query: '',
    })
    const savedMessages = verifyResult.messages || []
    console.log(`[AgentService] Memory verification: ${savedMessages.length} messages found in thread ${threadId}`)
    
    if (savedMessages.length === 0) {
      console.warn(`[AgentService] WARNING: No messages found after generation. This may indicate agent.generateLegacy() did not save messages.`)
    }
  } catch (error) {
    console.error(`[AgentService] Error verifying message persistence:`, error)
  }

  // Update thread timestamp
  await storage.updateThread({
    id: threadId,
    title: thread.title || 'Chat',
    metadata: thread.metadata || {},
  })

  const now = new Date()
  
  // Generate IDs for the response (these are for the API response, not the stored messages)
  // The actual messages are saved by the agent's Memory instance with its own IDs
  const userMsgId = `msg-${Date.now()}-user`
  const assistantMsgId = `msg-${Date.now()}-assistant`

  return {
    userMessage: {
      id: userMsgId,
      role: 'user',
      content: message,
      createdAt: now,
    },
    assistantMessage: {
      id: assistantMsgId,
      role: 'assistant',
      content: response.text,
      createdAt: now,
    },
    threadId,
    workingMemorySummary,
  }
}

/**
 * Get conversation history for a thread
 */
export async function getHistory(
  userId: string,
  threadId: string
): Promise<AgentMessage[]> {
  await ensureStorageInitialized()

  console.log(`[AgentService] Getting history for thread ${threadId}, resource ${userId}`)

  // Use recall method to get messages
  let messages: any[] = []
  try {
    const recallResult = await (memory as any).recall({
      threadId,
      resourceId: userId,
      query: '',
    })
    messages = recallResult.messages || []
    console.log(`[AgentService] Recall returned ${messages.length} messages`)
  } catch (error) {
    console.error(`[AgentService] Error with recall:`, error)
    messages = []
  }

  // Extract text content from messages (messages from recall() have complex content structure)
  const extractTextContent = (msg: any): string => {
    if (typeof msg.content === 'string') {
      return msg.content
    }
    if (msg.content?.content) {
      return typeof msg.content.content === 'string' ? msg.content.content : JSON.stringify(msg.content.content)
    }
    if (msg.content?.parts && Array.isArray(msg.content.parts)) {
      return msg.content.parts.map((p: any) => p.text || '').join('')
    }
    return JSON.stringify(msg.content)
  }

  return messages
    .filter(msg => msg.role === 'user' || msg.role === 'assistant')
    .map(msg => ({
      id: msg.id,
      role: msg.role as 'user' | 'assistant',
      content: extractTextContent(msg),
      createdAt: msg.createdAt || new Date(),
    }))
}

/**
 * Get all threads for a user
 */
export async function getThreads(userId: string): Promise<AgentThread[]> {
  await ensureStorageInitialized()

  // Use Memory instance method - listThreadsByResourceId
  const result = await (memory as any).listThreadsByResourceId({ resourceId: userId })
  
  // The result may be an object with threads property or an array directly
  const threads = result?.threads || result

  // Ensure threads is an array before mapping
  if (!Array.isArray(threads)) {
    console.error(`[AgentService] listThreadsByResourceId returned non-array:`, typeof result, result)
    return []
  }

  return threads.map((t: any) => ({
    id: t.id,
    title: t.title,
    createdAt: t.createdAt,
    updatedAt: t.updatedAt,
  }))
}

/**
 * Get or create a thread
 */
export async function getOrCreateThread(
  threadId: string,
  userId: string,
  title?: string
): Promise<AgentThread> {
  await ensureStorageInitialized()

  const existing = await storage.getThreadById({ threadId })

  if (existing) {
    return {
      id: existing.id,
      title: existing.title,
      createdAt: existing.createdAt,
      updatedAt: existing.updatedAt,
    }
  }

  const thread = await storage.saveThread({
    thread: {
      id: threadId,
      resourceId: userId,
      title: title || 'New Chat',
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: {},
    },
  })

  return {
    id: thread.id,
    title: thread.title,
    createdAt: thread.createdAt,
    updatedAt: thread.updatedAt,
  }
}

/**
 * Create a new thread
 */
export async function createThread(
  userId: string,
  title?: string
): Promise<AgentThread> {
  const threadId = `thread-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
  return getOrCreateThread(threadId, userId, title)
}

/**
 * Delete a thread and its working memory
 */
export async function deleteThread(
  userId: string,
  threadId: string
): Promise<void> {
  await ensureStorageInitialized()

  // Delete the thread from storage
  await storage.deleteThread({ threadId })

  // Also clear working memory for this thread
  const { clearWorkingMemory } = await import('./workingMemoryService.js')
  await clearWorkingMemory(userId, threadId)
}

/**
 * Update thread title
 */
export async function updateThreadTitle(
  threadId: string,
  title: string
): Promise<AgentThread> {
  await ensureStorageInitialized()

  const existing = await storage.getThreadById({ threadId })
  if (!existing) {
    throw new Error(`Thread ${threadId} not found`)
  }

  await storage.updateThread({
    id: threadId,
    title,
    metadata: existing.metadata || {},
  })

  return {
    id: existing.id,
    title,
    createdAt: existing.createdAt,
    updatedAt: new Date(),
  }
}

/**
 * Get working memory state for a thread
 */
export async function getThreadWorkingMemory(
  userId: string,
  threadId: string
) {
  return getWorkingMemory(userId, threadId)
}

/**
 * Update working memory for a thread
 */
export async function updateThreadWorkingMemory(
  userId: string,
  threadId: string,
  key: string,
  value: any
) {
  return setWorkingMemory(userId, threadId, key, value)
}
